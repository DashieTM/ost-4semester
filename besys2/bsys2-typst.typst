#import "../template.typst": *

#show: doc => conf(
  author: "Fabio Lenherr",
  "Operating Systems 2",
  "summary",
  doc,
)

#section("Sinals, Pipes and Sockets")
#subsection("Signals")
Signals allow you to mimmick an interrupt, e.g. if a signal is sent to a process, then the OS will simply treat this like an interrupt.\
- process is interrupted
- A Chosen Signal-Handler-Function is chosen
- run said function
- continue process (if the Signal-Handler-Function doesn't end the process)

#subsubsection("Signal Origins")
- Hardware/OS
  - illegal instructions
  - access on illegal memory -> segfault
  - division by 0
- other processes
  - \<C-c\> entered
  - processes such as kill, killall etc.

#subsubsection("Handling of Signals")
- each process has *1 handler per signal*
- On process begin, there is a default handler (1 of 3) for each signal:
  - ignore-handler: ignore the signal
  - terminate-handler: terminates the program
  - abnormal-terminate-handler: terminates the program and generates a dore dump
- pretty much all Signal-Handlers can be overwritten (exceptions: _SIGKILL and SIGSTOP_)

#subsubsection("Important Signals")
#subsubsubsection("Program defects")
- #text(purple, [SIGFPE]): error in arithmetic operation
- #text(purple, [SIGILL]): unknown instruction
- #text(purple, [SIGSEGV]): illegal memory access
- #text(purple, [SIGSYS]): unknown system call -> syscall unknown code

#subsubsubsection("Program cancel")
- #text(purple, [SIGTERM]): the regular, formal way to request program termination
- #text(purple, [SIGINT]): A more pushy way to ask the program to terminate\
  generated when the user enters \<C-c\>
- #text(purple, [SIGQUIT]): like SIGINT, but abnormal termination â†’ core dump generated\
  generated when the user enters \<C-\\\>
- #text(purple, [SIGABRT]): same as SIGQUIT, but preferably only called when the process notices an error by itself\
  see panic in rust
- #text(purple, [SIGKILL]): last resort, *process can't block, ignore, or catch this request*\
  process will definitely be killed

#subsubsubsection("Stop And Continue")
- #text(purple, [SIGSTP]): process is put into stopped mode (similar to waiting)\
  can be caused by user -> \<C-z\>
- #text(purple, [SIGSTOP]): like SIGSTOP, but can't be ignored or catched
- #text(purple, [SIGCONT]): immediately continues the process\
  can be done in the shell with fg, or bg -> foreground and background

#subsubsection("Sending signals from shell")
You can send signals from the shell with commands:
```bash
kill 1234 5232 -- process 1234 and 5232 asked to terminate -> SIGTERM
kill -KILL 1234 SIGKILL sent to process 1234 
kill -l -- list all signal possibilities
```
#subsubsection("Custom Signal Handler")
```C
int sigaction (
  int signal,
  struct sigaction *new,
  struct sigaction *old)
```
- signal is the number of the signal (_SIGKILL or SIGSTOP_ not allowed!)
- defines signal-handler for signal *if new is not 0*
- returns the current signal-handler for signal *if old is not 0*

#subsubsubsection("Sigaction Struct")
```C
struct sigaction {
  void (*sa_handler)(int);
  sigset_t sa_mask;
  int sa_flags;
};
```
- sa\_handler: address of function which will be called when a signal is received
- sa\_mask: defines which signals will be blocked when the handler runs (own signal is always blocked)
- sa\_flags: allows multiple additional properties

#subsubsubsection("Specifying the Signal")
We can specify the signal for the handler with sigset\_t.\
sigset is a set of signals and it can be interacted with by these functions:
- #text(purple, [int sigemptyset (sigeset\_t \*set)]): no signal chosen
- #text(purple, [int sigfillset (sigeset\_t \*set)]): all signals chosen
- #text(purple, [int sigaddset (sigeset\_t \*set)]): adds a signal to the set
- #text(purple, [int sigdelset (sigeset\_t \*set)]): removes a signal from the set
- #text(purple, [int sigismember (sigeset\_t \*set)]): returns 1 when the signal is inside the set

#subsection("Pipes")
#subsubsection("Duplicating File Descriptors")
```C
int dup (int source_fd);
int dup2 (int source_fd, int destination_fd);
```
- both functions duplicate the source file descriptor and return the new one
- dup allocates a new file descriptor
- dup2 overwrites an existing filedescriptor
Usage:
```C
int fd = open ("log.txt", ...);
int id = fork ();
if (id == 0) // child {
  // duplicate fd for log.txt as standard output
  dup2 (fd, 1);
  // e.g. load new image with exec*,
  // file descriptors remain
}
else { // parent
  close (fd);
}
```
#subsubsection("Abstract Files")
While the POSIX philosophy is that everything is a file, this is obviously not the truth.\
Hence we have things that are "abstract files", like a terminal etc.\
The idea is that _everything that can be opened, closed, read, or written_ is a file.\
In fact, the terminal can indeed do this :)\
- if it implemented read,write,open,close -> its a file
- lseek is not needed for this
- C-APPI-FIles (FILE \*) can basically use any POSIX file!

#subsubsection("Pipe Explanation")
#text(purple, [A pipe is a file in memory, which can be used over 2 file descriptors:\
- read end: in order to read from the pipe
- write end: in order to write into the pipe
])
- Data which will be written into _write end_ can be read from _read end_ *exactly once* -> FiFo
- Pipes do not support lseek
- Pipes allow communication over regular process boundaries
- Example in shell (wrapper for a real pipe): cat file | rg "your string to search"

#subsubsubsection("Reading from a Pipe")
- You can read from a pipe as if it is a file
- If there is no data in the pipe, then it will block until there is data
- If there is no data in the pipe, and there is no open write-end, then it returns 0 (EOF)
- reading process must close it's write-end -> should not do both at the same time!
- writing process will signal the end of communication by closing the write-end

#subsubsection("Pipe Example in C")
```C
int pipe (int fd [2]); // equivalent to int pipe (int *fd)
```
- Creates a pipe and the 2 needed file descriptors, which will be placed in the fd array
- Pipe lives as long as it is open in the process
- return value is 0 for ok, -1 if error and code in errno
- under linux, the default pipe size is 16 pages (1 page = 4KB -> 64KB)
- can be used like a file with close, read, write -> open already, no need for that
Example Usage:
```C
int fd [2];
pipe (fd);
int id = fork ();
if (id == 0) { // child
  close (fd [1]); // don't use write end
  char buffer [BSIZE];
  int n = read (fd[0], buffer, BSIZE);
} else {
  // parent
  close (fd [0]); // don't use read end
  char * text = "pingpang";
  write (fd [1], text, strlen(text) + 1);
}
// the idea is we read from parent, and then proceed to write to child. 
```

#subsubsection("Example from shell to C")
shell
```bash
cmda | cmdb
```
C
```C
int fd [2];
pipe (fd);
int id1 = fork ();
if (id1 == 0) { 
  // child (cmda)
  // don't use read end
  close (fd [0]);
  // define pipe write end as stdout
  dup2 (fd [1], 1);
  exec ("cmda", ...);
} else {
  // parent (shell)
  int id2 = fork ();
  if (id2 == 0) { 
    // child (cmdb)
    // don't use write end
    close (fd [1]);
    // define pipe read end as stdin
    dup2 (fd [0], 0);
    exec ("cmdb", ...);
  } else {
    // parent (shell)
    wait (0);
    wait (0);
  }
}
```

#subsubsection("Named Pipes")
```C
int mkfifo(const char *path, mode_t mode);
```
- creates a pipe with a name and a path in the filesystem
- has permission bits like a normal file
- lives independently of the creating process, depending on the system even lives after reboot
- must be deleted like a link -> unlink pathtopipe

#subsubsection("Note about Pipes")
- Pipes are unidirectional: not specified what happens when we write into read-end or read from write-end
- reading process should close write-end
  - reason: if all read-ends are closed, then process with open write-end receives SIGPIPE (no readers left, stop writing!)
- Transferring of data between reader and writer depends on implementation
- multiple writes can be condensed into one (if they are in order and follow immediately)
- read receives all data at once
- reading once does not mean that there won't be more to read later

#subsection("Sockets")
#subsubsection("Berkeley Sockets")
- Berkeley sockets are an abstraction over communication mechanisms
  - examples: UDP, TCP
- Sockets are represent an endpoint on a machine
- *Sockets require a name(e.g. IP, Port-number)* -> apache on 127.0.0.1 8080  
#align(center,[#image("../Screenshots/2023_05_02_06_05_29.png", width: 50%)])

#subsubsection("Creating a Socket")
```C
int socket(int domain, int type, int protocol);
```
- Creates a new socket as a file
- scokets are not named at first
- all operations on socket are blocking by default(can be configured)
- returns the file descriptor (>=0) or -1 on error with code in errno

#subsubsubsection("Details")
- domain: the address domain
  - AF\_UNIX: internal socket for the machine -> paths in a machine\
    Example: acpid
  - AF\_INET: internet IPV4 
  - AF\_INET6: internet IPV6
- type: communication type
  - SOCK\_DGRAM: Datagram-Socket -> simple, unreliable, unidirectional, connectionless communication (UDP)
  - SOCK\_STREAM: Datagram-Socket -> reliable, bidirectional, connection oriented communication (TCP)
- protocol: system specific
  - 0 means the default based on other 2 parameters

#subsubsection("Socker usage Client")
Note that file functions can again be used
+ start connection: connect 
+ send data: send or write
+ receive data: recv or read
+ close connection: close

#subsubsection("Socker usage Server")
+ choose a name/address to bind the server to: bind
+ provide a queue for clients to send requests to: listen
+ create a connection with a requesting client: accept (creates new socket)
+ receive data: recv or read
+ send data: send or write
+ close connection: close
#text(teal,[obviously send or write are optional and can be repeated multiple times])

#subsubsubsection("Defining a regular Address")
```C
#include <sys/socket.h>

struct sockaddr {       // general interface
sa_family_t sa_family;  // address family
                        // (integer)
char sa_data[];         // address
                        // (variable-length data)
};
code
```
#subsubsubsection("Defining an IP-Address")
```C
#include <netinet/in.h>
struct in_addr {
  in_addr_t s_addr;       // 32-bit unsigned integer
}; 
struct sockaddr_in {      // internet (IP) address
  sa_family_t sin_family; // = AF_INET
  in_port_t sin_port;     // 16-bit unsigned integer
  struct in_addr sin_addr;
};
code
```
Usage:
```C
struct sockaddr_in ip_addr;
ip_addr.sin_port = htons (443);   // Default HTTPS port
inet_pton (AF_INET, "192.168.0.1", &ip_addr.sin_addr.s_addr);
// port in memory: 0x01 0xBB
// addr in memory: 0xC0 0xA8 0x00 0x01
code
```
- htons converts 16 Bit of host-byte-order (intel: little endian) to network-byte-order (always big endian), htonl 32Bit
- ntohs and nthol are the opposites to htons and htonl
- inet\_pton: converts protocol specific addresses from string to Netwrok-BO
- inet\_ntop: the opposite to pton

#subsubsubsection("Binding of a local Address")
```C
int bind (int socket,
          const struct sockaddr *local_address,
          socklen_t address_len);
```
- binds a socket to the specified, unused local address (error if bound)
- blocks until the binding is done
- returns 0 on ok, -1 on error with code in errno

#subsubsubsection("Starting a Connection")
```C
int connect (int socket,
             const struct sockaddr *remote_address,
             socklen_t address_len);
```
- binds a socket to the specified, unused local address (error if bound)
- tries to create a connection with the specified remote address
- blocks until the connectin is established or an (unspecified) timeout has been reached
- returns 0 on ok, -1 on error with code in errno

#subsubsubsection("Create Queue for Clients") 
```C
int listen (int socket, int backlog);
```
- marks the socket as ready for connections
- creates a queue, which can take as many connections as specified in the backlog, or the maximum default amount
- returns 0 on ok, -1 on error with code in errno

#subsubsubsection("Creating Sockets per Connection Request")
```C
int accept (int socket,
            struct sockaddr *remote_address,
            socklen_t address_len);
```
- waits until a connection is requested in the queue
  - then proceeds to create a new socket and binds it to a local address
  - the address of the client is written in remote\_address
  - the new socket can not accept any other connections, only the socket with the queue does that
  - returns file-descriptor of the new socket(>=0), otherwise -1 and code in errno

#subsubsubsection("Typical usage with a server")
```C
int server_fd = socket (...);
bind (server_fd, ...);
listen (server_fd, ...);
while (running) {
  int client_fd = accept (server_fd, 0, 0);
  // will call close(client_fd)
  delegate_to_worker_thread (client_fd);
}
```

#subsubsubsection("Sending and Receiving of Data (example)")
```C
ssize_t send (int socket,
              const void *buffer,
              size_t length, 
              int flags);
ssize_t recv (int socket,
              void *buffer,
              size_t length, 
              int flags);
```
- send (fd, buf, len, 0) = write (fd, buf, len)
- recv (fd, buf, len, 0) = read (fd, buf, len)
- flags: special stuff, don't care
- *buffering of data is the job of the network stack, we don't care about it*

#subsubsubsection("Closing of a Socket")
```C
int close (int socket);
```
- closes the socket for the calling process
- if another process still has this socket open, then the connection will stay (socket not closed)
- the opposite side will *not* be noticed if this socket is closed (only applies to the opposite side if no connection is running right now)
- the opposite side will not receive an EOF on read (there is no eof in a socket :) ) and the client does not leave the read-queue

#subsubsubsection("Shotdown of a Socket")
```C
int shutdown (int socket, int mode);
```
- closes the socket for *all processes* and stops all connections
- mode SHUT\_RD: no read access from now till shutdown
- mode SHUT\_WR: no write access from now till shutdown
- mode SHUT\_RDWR: no read OR write access from now till shutdown

#section("Message Passing")
#text(purple, [An operation consisting of 2 things:])
- Send: Copies the message from one process to another
- Receive: Copies the message from one processor into this one

#subsection("Implemenation differences")
- fixed or variable size
  - message passing with fixed size is tedious -> if message doesn't match, you would need to split it etc\
    more memory is used in order to communicate -> split messages -> inefficient
  - message passing with variable size is more work to implement
- direct or indirect communication
- synchronous or async communication
- buffering
- with or without message priority

#subsubsection("Direct Communication")
#subsubsubsection("Sending of Messages")
- process 1 sends message to process 2
- process 1 needs to know process 2 -> must know id
- communication solely between 2 processes

#subsubsubsection("Receiving of Messages")
- symetric: receiver must know name/alias/id of sender
- asymetric: receiver does not need to now id -> receives it via out-parameter

#subsubsection("Indirect Communication")
- acts like a mailbox
  - process p1 sends message to queue Q
  - process p2 receives message from queue -> receive(Q,message)
- Communication requires that both processes use the same queue
- there can be multiple queues between two processors

#subsubsubsection("Indirect Communication with more than 2 processes")
- Which process is the receives in multiprocessor queue? Solutions:
  - restrict queue to only one sender or receiver
  - restrict calls to receive of queue to 1 process
  - random selection
  - selection via algorithm -> round robin

#subsubsubsection("Lifecycle of a Queue")
- If the queue belongs to a process -> queue lives as long as owner process
- If the queue belongs to the OS -> queue exists independent from processes\
  OS has functions to deal with creation, deletion for queues -> we don't care

#subsubsection("Message Synchronization")
#text(purple,[We can send messages synchronous -> blocking, or async -> non-blocking])
- blocking send: sender is blocked until the endpoint has received the message
- non-blocking send: sender sends the message and doesn't care anymore
- blocking receive: reciever is blocked until message is available
- non-blocking receive: receiver gets message or 0 if none is available\
  0 as a supposed error message

#subsubsubsection("Rendevous")
#text(purple,[If receiver and sender are both blocked, then there will be a rendezvous as soon as both made their call])
- OS can omit one copy operation and directly copy the message from one process to the other
- implicit synchronization mechanism
- trivial implementation of the producer-consumer problem

#subsubsubsection("Producer-Consumer Problem")
```C
// Producer
message msg;
open (Q);
while (1) {
  produce_next (&msg);
  send (Q, &msg);
}

// Consumer
message msg;
open (Q);
while (1) {
  receive (Q, &msg);
  consume_next (&msg);
}
```

#subsubsubsection("Buffering in Message-Passing")
- no buffering: queue length is 0 -> no messages can be saved, only blocking send and receive will work
- restricted: N (variable) can be saved, send and receive most block when full
- no restriction: save until pc explodes

#subsubsubsection("Message-Passing Priority")
Some systems allow for priority setting with messages, in this case the higher priority messages will be selected first.

#subsubsection("POSIX Message-Passing")
- indirect communication over message-queues that exist in the OS
- variable message size, with a configurable max depending on queue
- synchronous and async usage
- priority -> min 32 (32K on linux)
- more info: man mq\_overview

#subsubsubsection("mq\_open")
```C
mqd_t mq_open (const char *name, int flags,
               mode_t mode,
               struct mq_attr *attr);
```
- opens a message-queue with system name
- returns a message-queue-descriptor
- *should begin with a / and not contain any other / -> otherwise result implementation dependent*
- flags:
  - 0\_RDONLY: read only
  - 0\_RDWR: read and write
  - 0\_CREAT: creates queue if it does not exist
  - 0\_NONBLOCK: send and receive do *not* block
- mode: sets access permissions -> S\_IRUSR | S\_IWUSR
- mq\_attr: see next 

#subsubsubsection("mq\_attr")
```C
struct mq_attr {
  long mq_flags;   // flags: 0 or 0_NONBLOCK
  long mq_maxmsg;  // Max. number of messages on queue
  long mq_msgsize; // max. message size (bytes)
  long mq_curmsgs; // number of messages currently in queue
};
```
- used in mq\_open: or 0 for default values
- can be read with mq\_getattr
- can be set with mq\_setattr

#subsubsubsection("mq\_close")
```C
int mq_close(mqd_t queue);
```
- closes the queue with the descriptor queue for this process
- queue will still be in system -> removal is another function, see below 

#subsubsubsection("mq\_unlink")
```C
int mq_unlink(const char *name);
```
- removes the queue with the name in the system
- name will be removed immediately (flagged for removal)
- queue will be removed as soon as all processes have closed the queue

#subsubsubsection("mq\_send")
```C
int mq_send (mqd_t queue, const char *msg,
             size_t length, unsigned int priority);
```
- sends the message to the address msg with length (bytes) to the queue
- blocks only if the queue is full\
  *even if 0\_NONBLOCK is set!*
- variant with timeout -> mq\_timedsend

#subsubsubsection("mq\_receive")
```C
size_t mq_receive (mqd_t queue, char *msg,
                size_t length, unsigned int *priority);
```
- copies the next message from the queue to the buffer which exists on the address msg with lentgh (bytes)\
  *buffer must be minimum as big as the max message size defined in mq\_attr!!*
- blocks when the queue is empty\
  *even if 0\_NONBLOCK is set!*
- variant with timeout -> mq\_timedreceive
- priority is an out-parameter -> priority for receiving message
- if return is -1 -> error

#section("Shared Memory")
Multiple processors that can access the same memory.\
However from bsys1, we know that each processor has its own virtual memory. V1 and V2\
This means both processors can act independently and access memory whenever without data races.\
*It also means that you need synchronization!*
#align(center, [#image("../Screenshots/2023_05_09_05_58_46.png", width: 70%)])
#text(purple, [Note, when you need to send an address to another process, *do not this with addresses*, it is different for another process!])
#align(center, [#image("../Screenshots/2023_05_09_06_02_13.png", width: 70%)])
2 Different addresses reference the same physical memory!

#subsubsection("Relative Addresses")
#align(center, [#image("../Screenshots/2023_05_09_06_04_11.png", width: 70%)])
#text(purple,[If you want to use pointers, then you have to use relative pointers -> as the relations are the same!\
The idea is, you share a starting address -> hey my starting address is 4000 -> and then go from there])

#subsection("Shared Memory in POSIX")
You need:
- an object modelled after a file which holds information about shared memory
- processes 
- 1 object per process that holds the mappings for a specific process 

#subsubsection("shm\_open")
```C
int shm_open (const char *name, int flags, mode_t mode);
```
- opens shared memory with a system name
- returns a file-descriptor
- name should begin with / and no more / in rest of name
- flags:
  - 0\_RDONLY: read only
  - 0\_RDWR: read write
  - 0\_CREAT: create shared memory if it doesn't exist
- mode: sets permissions S\_IRUSR | S\_IWUSR
Examples:

```C
// open mysharedmemory (create if not exist) and set permission to read and write
int fd = shm_open ("/mysharedmemory", O_RDWR | O_CREAT , S_IRUSR | S_IWUSR );

// open mysharedmemory with permission read only
int fd = shm_open ("/mysharedmemory", O_RDONLY, 0);

```

#subsubsection("ftruncate")
```C
int ftruncate (int fd, offset_t length);
```
- standard function for all files -> set size
- returns 0 on ok, otherwise -1 and error code in errno
- *must be set*, to allocate amount of frames
- used for shared memory with multiples of page/framesizes

#subsubsection("close")
```C
int close(int fd);
```
- standard function for all files -> closes file
- returns 0 on ok, -1 if error and error code in errno
- *shared memory stays in system!* even if no process uses said memory anymore

#subsubsection("shm\_unlink")
```C
int shm_unlink(const char *name);
```
- deletes shared memory with the name in the system (flagged for removal)
- only deletes when no process uses this anymore

#subsubsection("mmap")
```C
void * mmap (
        void *hint_address,
        size_t length,
        int protection,
        int flags,
        int file_descriptor,
        off_t offset);
```
#text(purple,[This is a multi use function, but we can use it for shared memory:])
```C
void * address = mmap (
    0,                        // void *hint_address,
    size_of_shared_memory,    // size_t length,
    PROT_READ | PROT_WRITE,   // int protection,
    MAP_SHARED,               // int flags,
    fd,                       // int file_descriptor,
    0                         // off_t offset
);
```
maps the shared memory, with which the file-descriptor was opened into the virtual address space of the currently running process, and returns the virtual address of the first byte

#subsubsection("munmap")
```C
int munmap(void *address, size_t length);
```
#text(purple, [remvoes the previously set mapping])

#subsection("Message-Passing vs Shared Memory")
#text(purple, [Shared memory is often the faster approach])
- existing applications with one process relatively easily can be mapped to multiple processes with shared memory
  - such programs are often not that maintainable
- often result is async, but not parallel -> dependency chain
- system is less modular and processes are not as protected from each other

#text(purple, [Message-Passing requires more engineering])
- existing applications often need to be reimplemented
  - less of a problem for properly coded applications
- applications with message-passing can be extended easily
- sometimes implemented in OS -> QNX (wtf?)

#text(purple, [Performance Comparison])
- single processor systems are better with shared memory
- multi-processor systems are a bit more complex\
  due to caching, shared memory often needs more time and more synchronization, which reduces the performance advantage over message passing\
  often, message passing is as fast as shared memory with these systems, and in the future, message-passing is likely to be faster

#subsection("Message-Passing vs Pipes")
- Pipes are unidirectional, message-queues are bidirectional
- pipes send and receive bytestream of data, data in message-queues are organized over individual messages
- pipes allow FIFO, while message-queues allow random access
- pipes don't need to have a name in the file system (named pipes are optional), message-queues however *always need a name*

#section("Encoding")
#subsection("ASCII")
#align(center, [#image("../Screenshots/2023_05_16_05_02_35.png", width: 70%)])
- 7 bit -> 128 symbols -> 00h to 7Fh
- 33 symbols are obsolete
- 10 digits
- 26 uppercase letters
- 26 lowercase letters
- 33 special characters

#subsubsection("Extensions")
In order to display more symbols, something like "umlaut".\
Note that these extensions are 1 bit -> extension from 7 bit to 8 -> 128 symbols (80h-FFh).\
Also, programs need to know which extensions are used in order to properly display it.\
E.g. if you encode with german umlauts, but the decoder decides that they are cyrillic symbols, then garbage will displayed!

#subsection("Unicode")
- 149,186 symbols
- work in progress
- certain code points not used due to encoding -> see utf16 encoding
- allows emojis
- even used for dead languages
- code point(CP): number of a symbol
- code unit(CU): unit used to display a symbol in the encoding
- 3 main encodings 
  - UTF-32: each code point will be displayed with 1 Code Unit
  - UTF-16: each code point will be displayed with 1 or 2 Code Units
  - UTF-8: each code point will be displayed with 1 to 4 Code Units
  - Endian versions -> UTF-32BigEndian / UTF-32LittleEndian

#subsubsection("Endian")
#align(center, [#image("../Screenshots/dig/220614-4.png", width: 70%)])
#align(center, [#image("../Screenshots/dig/220614-5.png", width: 70%)])

#subsubsection("UTF-8")
#align(center, [#image("../Screenshots/dig/220614-6.png", width: 70%)])
#align(center, [#image("../Screenshots/dig/220614-7.png", width: 70%)])
#align(center, [#image("../Screenshots/dig/220614-8.png", width: 70%)])
#align(center, [#image("../Screenshots/2023_05_16_05_25_38.png", width: 70%)])
- 8 bit per CU
- *encoding doesn't have to adhere to endianness!!*
- can be seen as an extension to ascii
  - first 7 bits are the same
  - last bit special encoding
- note the bits used by default -> 10 means block coming
  - the start means block coming plus a 1 for each block -> 4 blocks == 11110, 3 blocks 1110

#subsubsection("UTF-16")
#align(center, [#image("../Screenshots/dig/220614-9.png", width: 70%)])
#align(center, [#image("../Screenshots/dig/220614-10.png", width: 70%)])
#align(center, [#image("../Screenshots/2023_05_16_05_27_53.png", width: 70%)])
- endianness has to be respected
- U_1 (D800 <= U_1 >= DBFF) is the high surrogate
- U_0 (DC00 <= U_0 >= DFFF) is the low surrogate
- codepoints above 10000h are supplementary codepoints
- codepoints c with p0000h <= c <= pFFFFh are on plane p
- p = 0 is the basic multilingual plane -> 1 UTF-16 block
- 1 <= p <= 16 are the supplementary planes

#subsubsection("UTF-32")
#align(center, [#image("../Screenshots/2023_05_16_05_21_14.png", width: 70%)])
- limited to 21bit -> rest are often used for other things
  - 21 bit for 21 code units
- often used internally in programs
- endianness has to be respected

#subsubsection("Encoding Example")
#align(center, [#image("../Screenshots/2023_05_16_05_24_39.png", width: 70%)])

#section("Ext2")
- first file system for linux
- extension for EXT -> the minix filesystem
- today replaced by EXT4
- good documentation available for EXT2 and EXT4

#subsection("Terms")
- partition: divides disk into smaller (virtual) disks
- volume: a drive or a partition
- sector: 
  - smallest logal unit of a volume -> data is transfered as sectors
  - size is defined by hardware (traditional: 512bytes, can also be 4Kbytes today)
  - includes header, data and error-correctoin codes
- format:
  - layout of the logical structure on a disk
  - defined by the filesystem -> EXT, BTRFS, NTFS, etc.

#subsection("Block")
#columns(2, [
- multiple sectors in a row
- 1KB, 2KB, or 4KB (default 4KB)
- a volume is divided into blocks
- allocation on disk is done in blocks
#colbreak()
#align(center, [#image("../Screenshots/2023_05_16_05_42_06.png", width: 70%)])
])

#subsubsection("Logical vs Physical")
#columns(2, [
- logical: block from file (data formatted as a block)
- physical: actual block in the volume
  - logical block is mapped to physical block
#colbreak()
#align(center, [#image("../Screenshots/2023_05_16_06_02_34.png", width: 70%)])
])

#subsection("Inodes")
#columns(2, [
- description of a file
  - size and count of blocks
  - creation time, access time, modification time, deletion time
  - owner id, group id, flags, permission bits
#colbreak()
#align(center, [#image("../Screenshots/2023_05_16_06_04_09.png", width: 70%)])
])

#subsubsection("Indirect Block")
- count of blocks after block12
- count of referenced blocks depends on blocksize
  - blocksize 1024byte -> 256 block numbers: block 12 to 267
  - blocksize 4096 -> 1024 block numbers: block 12 to 1035
#align(center, [#image("../Screenshots/2023_05_16_06_11_31.png", width: 70%)])

#subsubsection("Double Indirect Block")
- count of indirect blocks
- count of blocks depend on square of blocksize:
  - blocksize 1024 -> 256 entries per block -> 65536 blocks referenced: 268-65803
  - blocksize 4096 -> 1024 entries per block -> 1M blocks referenced: 1036-1,049,611
#align(center, [#image("../Screenshots/2023_05_16_06_13_59.png", width: 70%)])

#subsubsection("Triple Indirect Block")
- count of doubly indirect blocks
- count of blocks depend on cube of blocksize:
  - 1024 -> 256 * 256 * 256 = 16M blocks: 65804 to 16,843,019
  - 4096 -> 1024 * 1024 * 1024 = 1G blocks: 1,049,612 - 1,074,791,435
- max filesize would be bigger than 4TB, but 32-bit counter, so 4TB max

#subsubsection("Inode to file")
#columns(2, [
- array of blocks: i\_block with 15 entries of 32bit each
- 12 blocknumbers for the frist 12 blocks of a file
- 1 blocknumber of indirect block
- 1 blocknumber of doubly indirect block
- 1 blocknumber of triple indirect block
- each used block in a file has a direct, or (1-2-3x) indirect block

#colbreak()
#align(center, [#image("../Screenshots/2023_05_16_06_07_36.png", width: 80%)])
])

#subsection("Block Group")
#columns(2, [
- volume is divided into block groups
- blocksize the same for each block in size
- blockcount: up to 8 times the blocksize
#colbreak()
#align(center, [#image("../Screenshots/2023_05_16_06_18_42.png", width: 70%)])
])

#subsubsection("Layout of block group")
#text(purple, [The layout is weird, but is done because of the physical reader that mechanical harddrives had -> could only read one section per pass\
Multiple passes would mean too much latency, therefor all of this data encoded.])\
#text(red, [n: count of blocks in group descriptor table])
#text(red, [m: count of blocks in inode table])
- block0: copy of superblock
- block 1 to n: copy of groupdescriptortable
- block n + 1: block-usage-bitmap with a bit per block of group
- block n + 2: inode-usage-bitmap with a bit per inode of group
- block n + 3 to n + m + 2: table of all inodes in this group
- block n + m + 3 to end of group: Blocks with actual data 
#align(center, [#image("../Screenshots/2023_05_16_06_21_07.png", width: 70%)])

#subsection("Super Block")
- has metadata of volume
  - inodes
    - count of free inodes
    - count of all inodes
    - bytes per inode
    - inodes per group
    - first inode that can be used by applications
  - blocks
    - count of free blocks
    - count of all blocks
    - count of reserved blocks
    - bytes per block
    - blocks per group
  - mount time, write time, last accessed time
  - feature flags for this volume
- starts with byte 1024 (previously used for boot data, now no longer needed (empty))
#align(center, [#image("../Screenshots/2023_05_16_06_25_06.png", width: 70%)])

#subsection("Group Descriptors")
- 32Byte description of a blockgroup
- blocknumber of block-usage-bitmap
- blocknubmer of inode-usage-bitmap
- number of first block in inode-table
- count of free blocks in group
- count of free inodes in group
- count of directories in group

#subsection("Group Descriptor Table")
- table with n groupdescriptors for all n blockgroups in volume
- needs 32 * n bytes, count of sectors = 32 * n / sectorsize
- follows directly on superblock
- copy of table diretly after copy of superblock -> see layout
- n = count of blocks in this table

#subsection("Sparse Superblocks")
- feature that recudes the count of superblocks needed
- activated via flag
- when active, superblocks are only copied in blockgroups 0,1 and potences of 3,5, and 7:
  0,1,3,5,7,9,25,49,81,125,243,343
- recovery rate is still high enough with this amount of superblock copies
#align(center, [#image("../Screenshots/2023_05_16_06_31_37.png", width: 70%)])

#subsection("Position of Blockgroups")
- blocksize == 1024: 
  - block0 is brefore blockgroup 0
  - superblock in block 1
- blocksize > 1024: 
  - block0 is the first block in blockgroup 
  - superblock in block 0
#align(center, [#image("../Screenshots/2023_05_16_06_34_13.png", width: 70%)])

#subsection("Position of Inodes")
- all inodes are considered to be one full table
- count of inodes start with 1
- blockgroup of inode = (inodenumber - 1) / count of inodes per group
- inode index in blockroup = (inodenumber - 1) % count of inodes per group
- sector and offset can be determined by the data in the superblock
#align(center, [#image("../Screenshots/2023_05_16_06_36_52.png", width: 70%)])

#subsection("Creation of Inodes")
- find a good blockgroup (try to spread the equally)
  - new directory are preferredly allocated in the blockgroup with the most free blocks
  - files are preferrably allocated in the blockgroup of the directory, or in close groups
- determines the first free inodes in a group by the inode-usage-bitmap
  - bit is set to 1
  - count of free inodes in group descriptor and superblock are changed

#subsubsection("File Holes in Inodes")
- sections in a file, in which only 0s are stored
  /* - entry in block set to 0 -> means block only has 0s -> no data */
  - block will not be allocated
  - NTFS -> sparse files
#align(center, [#image("../Screenshots/2023_05_16_06_41_22.png", width: 70%)])

#subsection("Directories")
- has inodes for files (inodes describe files themselves)
- two automatic entries: 
  - inode for the directory itself
  - inode for the parent directory
  - root directory is *always* inode number 2
#align(center, [#image("../Screenshots/2023_05_16_06_43_02.png", width: 70%)])
- File entry: variable length 8-263bytes
  - 4Byte inode
  - 2Byte length of entry
  - 1Byte length of filename
  - 1Byte filetype(1: file, 2: directory, 7: symbolic link)
  - 0-255bytes filenames (ASCII)
  - length is always algined to 4Bytes(efficiency)
#align(center, [#image("../Screenshots/2023_05_16_06_43_26.png", width: 70%)])

#subsection("Links")
- Hard-Link: 
  - same inode
  - different paths
  - inode is referenced in different files
- symbolic-link:
  - file includes path of other file
  - if path is smaller than 60 characters, then path will be stored in the 15-index sized array of the blockreferences (i\_array), and no blocks are allocated\
    otherwise exactly 1 block is allocated

#section("EXT-4")
- Inodess 256bytes instead of 128
- groupdescriptors 64Bytes instead of 32
- Inodes manage blocks with "Extent Trees"
- Journaling
  - 2 layered: first data into journal, then position
  - solves consistency issues on power cut
  - just like databases

#subsubsection("Example consecutively stored File")
#text(red,[This is in ext2, to show why we want ext4 instead])
#align(center, [#image("../Screenshots/2023_05_23_05_26_01.png", width: 70%)])
- the first line is direct blocks
- the next few lines are indirect blocks
- from 801h onwards, we have doubly indirect blocks
- problem, with doubly indirect blocks, there are lots of allocations for no reason
  - instead we would like to express big files with as few bytes as possible, here we waste a lot
  - namely 12 \* 4B + 33 \* 4KB -> 132KB just to express one single file! (not the data itself!!)

#subsection("Extent Trees")
- big files are usually written consecutively
  - logical blocks are stored in physically consecutive blocks
  - jumps on disk are avoided -> bulk operations are faster
  - physical blocknumbers follow a simple increment system
  - block references also follow consecutive numbers
- defines an interval of consecutive physical blocks
  - starting logical blocknumber (4B)
  - starting physical blocknumber (6B)
  - blockcount (2B, signed)
  - hence, extent has 12Byte -> compare this to 132KB for ext2!
  - negative numbers -> blocks are initialized
  - positive numbers -> blocks are preallocated
#align(center, [#image("../Screenshots/2023_05_23_05_16_57.png", width: 70%)])

#subsubsection("Multi Extent")
#columns(2, [
#text(purple,[We can't always guarantee that a file is 100% consecutive, therefore we need multiple extents:])
- header is needed to combine all extents
- Inode has 15 \* 4 = 60Bytes for direct and indirect addressing of blocks
  - space for 4 extents and one header
#colbreak()
#align(center, [#image("../Screenshots/2023_05_23_05_20_49.png", width: 100%)])
])

#subsubsubsection("Extent Tree Header")
- for more than 4 extents, another block is needed
- therefore first 12bytes are not an extent, but an extent tree header -> space for more extent headers
  - magic number: 2bytes
  - count of entries following directly on a header: 2bytes
  - count of max entries following direclty on a header: 2bytes
  - depth: 2bytes
    - if depth is 0: entries are extents
    - if depth is 1: entries are index Nodes(see below)
  - 4bytes reserved

#subsubsubsection("Index Nodes")
#text(purple,[Not the same as inodes!!!!!])
- specifies a block, which holds extents
  - smallest possible logical blocknumber: 4Bytes
  - physical blocknumber of block that references this index node: 6Bytes
  - unused: 2Bytes
- block holds:
  - a header (like with inode, but depth is 0)
  - all extents (max 340 at blocksize == 4KB)

#subsubsubsection("Blocks with Index Nodes")
- for more than 4 \* 340 -> 1360 extents, you would need blocks with index nodes...
  - welcome back doubly indirect bs
  - depth 2 for this block, in index-nodes 1
  - smallest logical blocknumber is propagated through the tree
  - maximum depth is 5 -> 4M blocks per file max

#subsubsection("Tree Structure")
#align(center, [#image("../Screenshots/2023_05_23_05_43_06.png", width: 70%)])
- Index nodes
  - all layers other than leaves
  - index-entry (12Bytes) and index block
- index-entry
  - number for physical index-block
  - smallest logical number of all childnodes -> propagates up to top
    - helps with searching of logical blocknumbers in tree

#subsubsubsection("Index Blocks")
- includes the header for the own tree
- includes references to child nodes
- i\_block[0..14] in ext2 can be seen as a small index-block

Each of these lines is one index block:
#align(center, [#image("../Screenshots/2023_05_23_05_57_38.png", width: 70%)])
Another example:
#align(center, [#image("../Screenshots/2023_05_23_05_59_25.png", width: 70%)])

#subsection("Journaling")
#subsubsection("Motivation: extending of a file")
- new blocks for the data are allocated
- inode of file is updated to include new block references
- block-usage-bitmap are updated
- counter for free and used blocks are updated
- data is written
#text(purple,[Problem: what happens when the last part fails? We can't recover the data right now!])\
Note, not just the last part is problematic, any kind of failure after the first step is problematic! Potential conflicts!

#subsubsection("Motivation: Inconsistent Data")
Should our system suffer a crash, or even power outtage, we could be left with an inconsistent filesystem.\
In case of inconsistency this is what will happen: *all* metadata is checked\
#text(purple,[With journaling, only the metadata in the journal need to be checked!])

#subsubsection("Implementation")
#align(center, [#image("../Screenshots/2023_05_23_06_06_06.png", width: 70%)])
- Journal
  - reserved file for fast writing
  - typically Inode 8
  - typically 128MB
  - consists of few, but big extents, or in best case, 1 extent
- transaction
  - just like databases
  - ensures atomicity -> all or none

#subsubsubsection("Journaling and Committing")
#align(center, [#image("../Screenshots/2023_05_23_06_07_56.png", width: 70%)])
- data is first written to journal: *journaling*
- then data is committed to file: *committing*
- data is removed from journal
- journaling is fast since all data is written in consecutive blocks
- committing is slower, since it could have to modify a lot of blocks

#subsubsubsection("Replay")
- in case of a restart, the journal can check its metadata to see if the last transaction has been corrupted
  - -> transactions that are still in the journal are not fully completed
- Journal replay will execute these transactions again, or notices -> handles errors
- compared to ext2, not the entire disk needs to be checked for errors (massive speedup)

#subsubsubsection("Full Journal Mode")
#align(center, [#image("../Screenshots/2023_05_23_06_13_16.png", width: 70%)])
- positives: maximum data security
  - both metadata and regular data are journaled
- negatives: less speed

#subsubsubsection("Ordered Journal Mode")
#align(center, [#image("../Screenshots/2023_05_23_06_14_46.png", width: 70%)])
- only metadata is stored in journal
- data itself is written *before* commit!
  - 1 transaction into journal
  - 2 data is written to file
  - 3 committing
- positives:
  - files have right data after commit
  - faster than full journal
- negatives:
  - slower tha writeback
  - data can still be lost
    - aka error during writing means write all again
    - if data is only temporary, data can be lost!

#subsubsubsection("Writeback Journal Mode")
#align(center, [#image("../Screenshots/2023_05_23_06_16_49.png", width: 70%)])
- only metadata is stored in journal
- commit and write are done in a random order
- positives:
  - fastest mode
  - no synchronization needed between write and commit
- negatives:
  - data could have trash in it -> not completed
    - could be without error! commit before write is possible!
    - if data is only temporary, data can be lost!

#subsection("Comparison to Ext2")
- ext2
  - performant
  - easy to implement
  - more complex than FAT
  - less complex than NTFS
- ext4 
  - extension of ext2
  - journaling
  - efficient management of big directories and files via extents

#section("X11")
- used to be a pure text oriented interface
- just a terminal really
#set text(green)
positives:
- resource efficient
- for terminal usage sufficient
#set text(red)
negatives:
- restrictive for advanced applications
- not intuitive for non-terminal nerds
#set text(black)

#subsection("Terminal vs GUI")
Terminal:
#align(center, [#image("../Screenshots/2023_05_30_05_11_19.png", width: 70%)])
GUI:
#align(center, [#image("../Screenshots/2023_05_30_05_13_42.png", width: 70%)])
Terminal is the user reacting to the program, wile the GUI is reacting to the user via events.\
Remember, X11 is just a protocol that allows this by defining a standard to do so.

#subsection("An X server")
- builds on top of unix kernel
- installable if needed -> modular
- realizes network transparency (clients don't see where their GUI runs)
- platform independent (could also be run on windoof lol)
- X does not define how a client looks -> only implements rendering
- initially made for universities -> run virtual desktops somewhere else (remote desktop)
- good portability

#subsection("Windows in X")
#columns(2, [
- in wayland these are called clients
- every window has 0 to n child windows
- the root window is always the screen, which does not have a parent
- pretty much everything is a window
- child windows are only visible inside the parent window
  E.g. if you want a popup that should appear everywhere, you need to create another proper window!
- window classes
  - InputOutput
  - InputOnly (popup?)
#colbreak()
#align(center, [#image("../Screenshots/2023_05_30_05_22_15.png", width: 70%)])
])

#subsection("Mouse and other Input")
Mouse and keyboard inputs are handled via events, which are recorded by the drivers and then sent to the OS, which then relays that information to the application.
#align(center, [#image("../Screenshots/2023_05_30_05_25_39.png", width: 70%)])
- asynchronous
- OS sends multiple data for mouse -> position and click
- OS does not wait for application to handle event -> it will continue to update mouse as it would otherwise freeze

#subsubsection("Hotspot")
This refers to the actual position that will do the action, if the hotspot is not on the button, you will not click it.
#align(center, [#image("../Screenshots/2023_05_30_05_29_46.png", width: 70%)])

#subsection("From X to DE")
- X system (protocol and server): handles rendering
- Compositor/window manager: handle window snapping, window arranging, decorations etc.
- Desktop Environment: Add typical applications, taskbars, runners, dashboards, file managers, etc.

#subsection("CSD and SSD")
Many Window managers in X do SSD, which means it will decorate other windows with decorations.\
However that is not the only way to do it, GTK for example will always use CSD, here the windows themselves will draw their own decorations.\
#columns(2, [
CSD\
Positives:
- themeing will not break application look
- client independent of window manager
negatives:
- less customization
- less integration into DE
  #colbreak()
SSD\
Positives:
- integration 
- consistency with all decorations
- if app crashes, it can still be killed, as decorations are child windows of window manager
negatives:
- more work for window manager
- decorations can break on clients
])

#subsection("QT and GTK")
#align(center, [#image("../Screenshots/2023_05_30_05_58_11.png", width: 70%)])
- GTK: GUI library
- GDK: wrapper for xlib
- GLIB: datastructures etc.

#subsection("How these things work together")
#align(center, [#image("../Screenshots/2023_05_30_06_01_02.png", width: 70%)])
Note display, are the stack of screens, keyboard, pointing device etc.

#subsection("X server and client")
#align(center, [#image("../Screenshots/2023_05_30_06_02_19.png", width: 70%)])
The clients do not need to be on the same pc as the server, that's the idea of X as said above.

#subsection("Usage of Xlib")
- Special Datatype called Display, which holds information about a display
```C
// open an X display
// if displayname is NULL, then env variable is used
Display *XOpenDisplay(char *display_name)

// close display
void XCloseDisplay(Display *display)

// show display height
int XDisplayHeight(Display *display)

// show display width
int XDisplayWidth(Display *display)

// show root window -> window manager 
int XRootWindow(Display *display)

// various other parameters that are ommitted here
// returns the Window ID of the created window
// created windows are not shown at first!
int XCreateWindow(params)
// use this instead (simple variant of the above function)
int XCreateSimpleWindow(Display *display, int parentwindow, int x, int y, int width, int height, int border_width, int border_style, int window_style)
// x and y are coordinates of top left

// removes all child windows as well
 int XDestroyWindow(params)

// shows window, if parent window is also visible
// if window is overlapped, then it is not shown (below another window)
XMapWindow (Display *, Window)

// brings window to front (above other windows)
XMapRaised (Display *, Window)

// shows child windows 
XMapSubwindows (Display *, Window)

// hides a window and all its child windows
XUnmapWindow (Display *, Window)

// hides all child windows of a window
XUnmapSubwindows (Display *, Windo
```
- for each window that is shown, an *exposed* event is triggered
- for each window that is hidden, an *UnmapNotify* event is triggered

#subsection("Messages in the X Protocol")
4 types of messages:
- Requests
  Client -> Server
- Responses:
  Client \<- Server
- Events:
  Client \<- Server
- Errors:
  Client \<- Server

#text(purple,[ E.g. t the only thing that the client sends are requests.])\
*Requests are also buffered in order to not drop them if the server can't immediately act on them.\
This also makes it possible to send an array of requests to the server, instead of each request one at a time.*
- only send requests when necessary
- delete buffer on client if client starts to wait on event (send buffer first ofc)
- delete buffer when client-request needs a reply from server
- delete buffer when client explicitly wants this (call of XFlush())

#align(center, [#image("../Screenshots/2023_05_30_06_17_32.png", width: 70%)])

#subsubsection("Event buffering")
#text(red, [Events are double buffered, to ensure they do not get lost.])\
This means that the server sends the entire array, which the client then uses one by one.
#align(center, [#image("../Screenshots/2023_05_30_06_21_48.png", width: 70%)])
- Server side buffering checks for network availability -> for remote desktop
- client buffering holds events ready for client until usage
- client reads message-loops via XNextEvent()
- Each client decides at start which inputs to receive
  - via XSelectInput
  - selection per individual window -> popup might want different events
  - default is empty (ClientMessage always selected)
  - unwanted events are not sent to the window, instead they are sent to the parent
    - to the windowmangager if top parent doesn't want it either
    - this is also why the X protocol is unsecure

#subsubsubsection("Event Selection")
```C
XSelectInput (Display *display, Window w, long event_mask)
```
- sets mask for which events to include
- masks are predefined, e.g. ExposureMask for expose events
- exception: ClientMessage Events are always selected

```C
XNextEvent (Display *display, Event *event)
```
- copies the next event from the client event buffer in event parameter
- idenfitication of display and window is part of the event -> event.display and event.window

#subsubsubsection("Example Event handling in Client")
```C
while (1) {
  XNextEvent(display, &event);
  switch (event.type) {
    case Expose: // event that requires redraw 
      break;
    case KeyPress: 
      // handle keypress 
      // example exit -> if (keypress == Q) exit(0);
      break;
  }
}
```

#subsubsubsection("Event Datatype")
```C
typedef union _XEvent {
  // must not be changed;
  // first element
  int type;
  XAnyEvent xany;
  XKeyEvent xkey;
  XButtonEvent xbutton;
  /* ... */
} XEvent;

// usage 
XEvent event;
XNextEvent(display, &event);
XLookupKeysym(&event.xkey, 0)
```
- C-union over all event types -> size is biggest event
- 33 different event types with different sizes
- each event-type is a struct, which has "event" as first member
- program code should use the proper union-member based on type

#subsection("Drawing in X")
#align(center, [#image("../Screenshots/2023_05_30_06_32_14.png", width: 70%)])
server side data storing for reductin of network traffic
- holds information for client
- clients identify information with an ID
- therefore, no copying of complex datastructures is needed
  - just say changes on ID x

#subsubsection("Examples for Resources")
- Window: describes window properties
- Pixmap: Rastergraphics (for example icon redrawing)
- Colormap: Colortable (converts colorvector into proper colors)
- font
- graphics-context (GC): graphicselementproperties (line width, colors, fillpatterns) (same GC can be used for multiple graphicselements)

#subsubsection("Visbility and Redrawing of Windowcontent")
- buffering of hidden content
  - minimal: No buffering by xorg, client must redraw on becoming visible
  - optional: Xorg has background memory for this window -> usage on becoming visible for client
    - client can ask if this exists with: XDoesBackingStore()
- X-Ressource Pixmap:
  - server side graphicsmemory, allocated by client and usable by client
  - usage: for example -> write complex content in pixmap, then copy pixmap into window

#subsubsection("Graphic functions in X")
- picture display via raster graphics and colortable
- black-white: one bit per pixel
- colors or gray tones: multiple bits per pixel
  - no indirect color association to binary values
  - index in a colortable (color lookup table, colormap)
  - each window can theoretically have its own colortable
  - in partice often only one colortable for all applications 
  - reduction of bits per color from all *absolute displayable* colors, to all *simulatenously displayable* colors
    - this only applies to regular windows, videos, games etc can still have the full color spectrum
- drawing of primitives:
  - polygons
  - lines
  - dots
  - rectangles
  - radials
  - target for drawing:
    - pixmap
    - window

#subsubsection("Graphics functions and GC")
graphics functions need a graphics context (X Resource):
- sets properties that are not directly supported by systemcalls (line width etc.)
- client must first create GC before calling of a drawing function
- client can use multiple GC at a time
- XCreateGC creates a new GC
- XCopyGC copies GC
- XFreeGC destroys GC
- XDefaultGC returns the standard GC of the screen

#subsubsection("Graphic Primitives")
#text(orange,[the (s) means there is also a plural version -> multiple at once])
- simple forms
  - XDrawPoint(s)
  - XDrawLine(s)
  - XDrawSegments
  - XDrawRectangle(s)
  - XDrawArc(s)
  - XFillArcs
- Text
  - XDrawString
  - XDrawText
- Images
  - XPutImage
#subsection("Closing windows in X")
Since the button is usually done by the window manager and not by the client itself (unless CSD is used), then the windowmanager must send the client a message.\
However the window manager is also a client, so it sends a client Message called WM_DELETE_MESSAGE.\

#subsubsection("Atoms")
Instead of sending the string, we send an "atom" to the server to save bandwidth.\
```C
Atom XInternAtom (Display *, char *, Bool only_if_exists)
```
- WM_DELETE_MESSAGE has ID 5 -> char \* in the function will be 5
- converts the string (WM_DELETE_MESSAGE for our case) for the display
- only_if_exists: decides if the atom should be created if it doesn't exist
- Window properties are identified over atoms
  - windowmanager changes these properties with this
  - for each property there is accompying data -> string for title of window\
    Or a list of atoms

#subsubsection("Setting of Properties")
- X11 protocol defines a list of properties
- client can set the protocols to be used
  Client therefore saves the protocols in the WM_PROTOCOLS property\
  This can be done with XSetWMProtocols (Display *, Window, Atom *first_proto, int count)SetWMProtocols

```C
XSetWMProtocols (Display *, Window, Atom *first_proto, int count)
```
saves the atoms of first_proto in the WM_PROTOCOLS property\
The count is the amount of atoms in the first_proto array.

#subsubsection("Deleting a Window with the windowmanager")
```C
// define atom
Atom atom = XInternAtom (display, "WM_DELETE_WINDOW", False);
// register window
XSetWMProtocols (display, window, &atom, 1);

// ....

// then register event
switch (event.type) {
  case ClientMessage:
  if (event.client->data.l[0] == atom) { // handle exlit -> exit(0) }
  break;
}
```






