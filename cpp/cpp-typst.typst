#import "../template.typst": *

#show: doc => conf(
  author: "Fabio Lenherr",
  "C++ Advanced",
  "summary",
  doc,
)

#section("Memory Model and Atomics")
#subsection("The C++ standard")
#subsubsection("C++ Standard defines an abstract machine")
- describes how a program is executed
- Abstracts away platform specifics
- Represents the "minimal viable computer" requried to execute a valid C++ program

#subsubsection("The C++ abstract machine defines:")
- in what order initialization takes place
- in what order a program is executed
- what a thread is
- what a memory location is
- how threads interact 
- what constitutes a data race

#subsubsubsection("Memory Location")
An object of scalar type:
- arithmetic
- pointer
- enum 
- std::nullptr -> pointer to 0 

#subsubsubsection("Conflict")
- two expression evaluations run in parallel and both access the same *Memory Location*
-> one writes, the other reads -> see rust borrow checker

#subsubsubsection("Data Race")
The program contains two conflicting actions -> *Undefined Behavior*

#subsection("Memory Model")
- defines when the effect of an operation is visible to other threads -> when change happens globally
- How and when operations might be reordered -> reordering of code lines

#text(red, [Note: Reads/Writes in a single statement are "unsequenced" -> they are not in guaranteed order, see SQL problems])
```cpp
std::cout << ++i << ++i; // output not deterministic!
```

#subsubsection("Visibility of effects")
- sequenced-before: within a single thread\ 
  _as code was written_\
  #text(red, [Note, this is only guaranteed for multi line statements, not for single line statements like cout!! -> see Note above])
- happens-before: either sequences-before or inter-thread happens-before\ 
- synchronizes-with: inter-thread sync.

#subsubsection("Ordering")
This is the way code is executed -> as written ? Can the compiler reshuffle for optimizations?
- Sequentially-consistent: "intuitive" and the default behavior\
  _as code was written_\
  #text(red, [When you change away from this, make sure you actually *NEED* another ordering!!])
- Acquire/Release: weaker guarantees than Sequentially-consistent\
  _can reshuffle_
- Consume (_discouraged_): slightly weaker than acquire-release
  _can reshuffle_
- Relaxed: No guarantees besides atomicity!
  _can reshuffle_

#subsection("Atomics")
Definition:
```cpp
template<typename T>
struct atomic;

class atomic_flag;
```
- Template class to create atomic types
- _Atomics are guaranteed to be data-race free!_
- Several spezializations in the standard library
- Most basic atomic: std::atomic\_flag
  - Guaranteed to be lock-free
  - clear() - sets the flag to false 
  - test\_and\_set() -set flag to true and return old value
- Other atomics might use locks internally 
  - check with is\_lock\_free()

Usage:
```cpp
auto outputWhenReady(std::atomic_flag & flag,
                     std::ostream & out) -> void {
  while (flag.test_and_set())
    yield();
  out << "Here is thread: “
      << get_id()
      << std::endl;
  flag.clear();
}
auto main() -> int {
  std::atomic_flag flag { };
  std::thread t { [&flag] {
    outputWhenReady(flag, std:: cout);}
  };
  outputWhenReady(flag, std::cout);
  t.join();
}
```
The reason why only these 2 are implemented -> clear and test\_and\_set, is that these 2 functions are supported by _all_ CPUs!

#subsubsection("Operations on Atomics")
#text(red, [Using your own types with std::atomic is possible, but they must be *trivially-copyable* -> no container in container etc.])
#align(center, [#image("../Screenshots/2023_05_02_01_38_54.png", width: 50%)])
#text(purple, [spezializations like std::atomic<int> can provide things like ++, --, +=, etc.])

#subsection("Applying Memory Orders")
#columns(2,[
#text(purple, [All atomic operations take an additional argument to specify the memory order -> (std::memory\_order)])
- std::memory\_order::seq\_cst
- std::memory\_order::acquire
- std::memory\_order::release
- std::memory\_order::acq\_rel
- std::memory\_order::relaxed
- std::memory\_order::consume
#colbreak()
```cpp
auto outputWhenReady(std::atomic_flag & flag,
  std::ostream & out) -> void {
  while (flag.test_and_set(std::memory_order::seq_cst))
    yield();
  out << "Here is thread: “
      << get_id()
      << std::endl;
  flag.clear(std::memory_order::seq_cst);
}
auto main() -> int {
  std::atomic_flag flag { };
  std::thread t { [&flag] {
    outputWhenReady(flag, std::cout);}
  };
  outputWhenReady(flag, std::cout);
  t.join();
}
```
])

#subsection("Sequentially-Consistent Mode")
- Sequential Consistency 
  - Global execution order of operations
  - every thread observes the same order
- Memory order flag
  - std::memory\_order::seq\_cst
- Default behavior
- The latest modification (in the global execution order) will be available to a read

```cpp
// thread1
auto write_x() {
  x.store(true);
}
// thread2
auto write_y() {
  y.store(true);
}
// thread3
auto read_x_then_y() {
  while (!x.load());
  if (y.load()) ++z;
}
// thread3
auto read_y_then_x() {
  while (!y.load());
  if (x.load()) ++z;
}
```
#pagebreak()
#columns(2,[
*Z == 2*
#image("../Screenshots/2023_05_02_01_50_32.png")
#colbreak()
*Z == 1*
#image("../Screenshots/2023_05_02_01_51_03.png")
])

#subsection("Acquire/Release Mode")
Has 3 different versions:
- std::memory\_order::acquire
  - no reads or writes in the current thread can be reordered before this load
  - All writes in other threads that release the same atomic are visisble in the current thread
- std::memory\_order::release
  - No reads or writes in the current thread can be reordered after this store
  - All writes in the current thread are visible in the other threads that acquire the same atomic
- std::memory\_order::acq\_rel
  - Works on the latest value\
    #text(red, [This is the way to always receive the up-to-date value!])
Usage:
```cpp
x.test_and_set(std::memory_order::acq_rel);
```
#align(center, [*Z == 0* #image("../Screenshots/2023_05_02_02_07_10.png", width: 50%)])
The issue here is that you no longer have a guaranteed order, as you can see, the atomicity is given, but the order in which x and y are written or read is not consistent.\
Note, the ordering of x and y alone is still ok, but not the ordering of both combined.

#subsection("Relaxed Ordering Mode")
- No promises about sequence whatsoever
- No data-races for atomic values -> *the only guarantee*
- Order of observable effects can be inconsistent 
  - load and store operations can happen in parallel
- May be more "efficient" on certain platforms
  - less synchroniztion means less pipeline stalling or waiting for memory loads
- #text(red,[Extremely difficult to get right! You will need to prove the correctness of this program!])
```cpp
#include <atomic>
#include <thread>
#include <cassert>
std::atomic<bool> x{};
std::atomic<bool> y{};
std::atomic<int> z{};
auto write_x_then_y() -> void {
  x.store(true, std::memory_order::relaxed);
  y.store(true, std::memory_order::relaxed);
}
auto read_y_then_x() -> void {
  while(!y.load(std::memory_order::relaxed)); // Spin
  if(x.load(std::memory_order::relaxed))
  ++z;
}
auto main() -> int {
  auto a = std::thread{write_x_then_y};
  auto b = std::thread{read_y_then_x};
  a.join();
  b.join();
  assert(z.load() != 0);
}
```
#align(center, [*Z == 0* #image("../Screenshots/2023_05_02_02_11_20.png", width: 50%)])
Here no order guarantees are given at all, aka even the order of x and y themselves can be shuffled!!

#subsection("Release/Consume Ordering")
- #text(red, [Don't fucking use, even the standard tells you to not use this!])
- Similar to Acquire/Release
   - Introduces data-dependency concept
    - dependency-ordered-before
    - carries-a-dependency-to
    - Only dependent data is synchronized
    - Subtle difference == hard to use

#subsection("Custom Types with std::atomic")
```cpp
struct SimpleType {
  int first;
  float second;
}; // ok

// some that do not work:
struct NonTrivialCCtor {
  NonTrivialCCtor(NonTrivialCCtor const&) {
    std::cout << "copied!\n";
  } // ERROR: can't create nontrivial constructor -> only trivial copy allowed
};

struct NonTrivialMember {
  int first;
  std::string second;
}; // strings can't be copied trivially -> not usable!!
```
- You can not have a custom copy constructor
- You can not have a custom move constructor
- You can not have a custom copy assignment operator
- You can not have a custom move assignment operator
- *Object can only be accessed as a whole*
  - no member access operator in std::atomic

#section("Bibs and Bobs (volatile and Interrupts)")
#subsection("Volatile")
```cpp
volatile int mem{0};
```
- Semantics different from dotnot and Jafuck
- volatile prevents the compiler from optimizing the reads/write on this variable
- *Prevents reordering in the same thread _by the compiler!_*
  - Hardware might still reorder instructions, can't be solved by software
- Useful when accessing memory-mapped hardware
  - *never use it for inter-thread communication!*
- Currently there are proposals to reduce/remove volatile from the language -> replacement with library functionality and cleanup semantics
#text(red, [Again, whatever you learned in Parprog, this is different in CPP, it is only a flag to tell the compiler to not optimize, it doesn to do anything for thread synchronization or blocking!])

#subsection("Interrupts")
- Events coming from the OS/CPU
- Can be suppressed by the platform
- When an interrupt occurs, a previously registered function is called
  - such functions are called Interrupt Service Routines (ISRs)
  - ISRs should generally be short and must run to completion
- After the intterupt was handled, execution of the program resumes

#subsubsection("Interrupts and Shared Data")
- Data sharing between ISRs and normal programs need to be protected
  - All access must be atomic
  - Modiciations need to become visible
- Volatile helps regarding visibility
  - Supresses compiler optimizations -> makes sure read happens!
- Interrupts may need to be disabled temporarily to guarantee atomicity
- Refer to your hardware manual for specific details on how to deal with interrupts

#subsubsection("Interrupts Example")
- On AVR-based Arduinos, interrupts cannot be interrupted
  - Other platforms support so-called Interrupt-Nesting (e.g. ARM, Risc V, …)
- *Before accessing shared data, interrupts must be disabled and enabled afterwards*
  - noInterrupts() – disable interrupts
  - interrupts() – enable interrupts
- *Interrupts sources can be “external”, e.g.pins on the board*
  - check hardware manual..

```cpp
constexpr byte ledPin = 13;
constexpr byte switchPin = 2;
volatile bool ledState = LOW;
void toggleLed() {
  ledState = !ledState;
}
void setup() {
  pinMode(ledPin, OUTPUT);
  pinMode(switchPin, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(switchPin),
  toggleLed,
  CHANGE);
}
void loop() {
  noInterrupts();
  digitalWrite(ledPin, ledState);
  interrupts();
}
```

#section("Network")
#subsection("Sockets")
#align(center, [#image("../Screenshots/2023_05_09_01_13_51.png", width: 70%)])

#subsection("Client example with TCP socket")
#subsubsection("Creation of Socket")
```cpp
// create a context
// create a socket and add the context to it
asio::io_context context{};
asio::ip::tcp::socket socket{context};
```
#align(center, [#image("../Screenshots/2023_05_09_01_15_16.png", width: 70%)])

#subsubsection("Connect to Socket")
```cpp
// with IP
auto address = asio::ip::make_address("127.0.0.1");
auto endpoint = asio::ip::tcp::endpoint(address, 80);
socket.connect(endpoint);

// with domain
asio::ip::tcp::resolver resolver{context};
auto endpoints = resolver.resolve(domain, "80");
asio::connect(socket, endpoints);
// we might have multiple answers here -> multiple DNS entries 
```
#align(center, [#image("../Screenshots/2023_05_09_01_16_18.png", width: 70%)])

#subsubsection("Write to socket")
```cpp
std::ostringstream request{};
request << "GET / HTTP/1.1\r\n";
request << "Host: " << domain << "\r\n";
request << "\r\n";
asio::write(socket, asio::buffer(request.str()));
```
#align(center, [#image("../Screenshots/2023_05_09_01_35_21.png", width: 70%)])

#subsubsection("Read from socket")
```cpp
constexpr size_t bufferSize = 1024;
std::array<char, bufferSize> reply{};
asio::error_code errorCode{};
auto readLength = asio::read(socket, asio::buffer(reply.data(), bufferSize), errorCode);
```
#align(center, [#image("../Screenshots/2023_05_09_01_36_27.png", width: 70%)])

#subsubsubsection("Advanced Read")
- *asio::read also allows you to specify completion conditions*
  - asio::transfer\_all: Default, transfers all available data or until buffer is full
  - asio::transfer\_at\_least(std::size\_t bytes): Read at least x number of bytes, but may transfer more
  - asio::transfer\_exactly(std::size\_t bytes): self explanatory
- *asio::read\_until allows you to specify conditions on the data being read*
  - simple matching of characters or strings
  - more complex matching using std::regex
  - allows you to specify a callable object -> expects std::pair\<iterator,bool\> operator()(iterator begin, iterator end)
  - *may read more! -> check the number of bytes returned!*

#subsubsection("Close socket")
- shutdown() closes the read/write stream associated with the socket, indicating to the peer that no more data will be received/sent.
- The destructor of the socket cancels all pending operations and destroys the object
```cpp
socket.shutdown(asio::ip::tcp::socket::shutdown_both);
socket.close();
```
#align(center, [#image("../Screenshots/2023_05_09_01_45_45.png", width: 70%)])

#subsection("Data Sources/Buffers")
- *ASIO does not manage memory for you*
- *Fixed size buffers using asio::buffers*
  - must provide at least as much memory as you would like to read
  - Can use several standard containers as a backend
  - Pointer + Size combinations are also available
- Dynamically sized buffers using asio::dynamic\_buffer()
  - for use with std::strng and std::vector -> heap
  - automatic resize as known by vector!
- Streambuf buffers using asio::streambuf
  - works with std::istream and std::ostream -> IO

#subsection("Server example with TCP socket")
#subsubsection("Creating socket")
- an acceptor is a special socket responsible for establishing incoming connections
- In ASIO the acceptor is bound to a given local endpoint and *starts listening automatically*
```cpp
asio::io_context context{};
asio::ip::tcp::endpoint localEndpoint{asio::ip::tcp::v4(), port};
asio::ip::tcp::acceptor acceptor{context, localEndpoint};
```
#align(center, [#image("../Screenshots/2023_05_09_01_47_44.png", width: 70%)])

#subsubsection("Accepting Connections")
- The accept() member function blocks until a client tries to establish a connection
- it returns a new socket through which the connected client can be reached
```cpp
asio::ip::tcp::endpoint peerEndpoint{};
asio::ip::tcp::socket peerSocket = acceptor.accept(peerEndpoint);
```
#align(center, [#image("../Screenshots/2023_05_09_01_49_03.png", width: 70%)])

#subsubsubsection("Handling multiple requests at once")
#align(center, [#image("../Screenshots/2023_05_09_01_55_19.png", width: 70%)])
#align(center, [#image("../Screenshots/2023_05_09_01_55_28.png", width: 70%)])
- The program invokes an async operation on an I/O object and passes a completion handler as a callback
- The I/O object delegates the operation and the callback to its io\_context
- The operating system performs the asynchronous operation
- The OS singals the io\_context that the operation has been completed
- When the program calls io\_context::run() the remainin asynchronous operations are performed (wait for the result of he OS)
- Still inside io\_context::run() the completion handler is called to handle the result (or error) of the asynchronous operation

#subsection("Asynchronous Read/Write on Sockets")
#columns(2,[
- Async read operations
  - asio::async\_read
  - asio::async\_read\_until
  - asio::async\_read\_at
#colbreak()
- Async write opertions
  - asio::async\_write
  - asio::async\_write\_at
])
- These functions *return immediately*
- The operation is processed by the executor associated with the streams asio::io\_context
- A completion handler is called when the operation is done
#align(center, [#image("../Screenshots/2023_05_09_02_19_01.png", width: 70%)])

#subsubsection("Example Asynchronous Read")
- asio::async\_read\_until 
  - reads from async stream into a buffer until specific character is encountered
  - then calls handler
  - completion handler takes asio::error\_code and size\_t as parameters
```cpp
auto readCompletionHandler = [] (asio::error_code ec, std::size_t length) {
  //...
};
asio::async_read_until(socket, buffer, '\n', readCompletionHandler);
```

#subsubsection("Example Asynchronous Write")
- asio::async\_write writes data from a buffer to async stream until all data bas been written or error occurs
- then calls completion handler
  - completion handler takes asio::error\_code and size\_t as parameters
```cpp
auto writeCompletionHandler = [] (asio::error_code ec, std::size_t length) {
  //...
};
asio::async_write(socket, buffer, writeCompletionHandler);
```

#subsubsection("Async Acceptor Overview")
```cpp
struct Server {
  using tcp = asio::ip::tcp;
  Server(asio::io_context & context, unsigned short port)
        : acceptor{context, tcp::endpoint{tcp::v4(), port}}{
    accept();
  }
private:
  auto accept() -> void {
    auto acceptHandler = [this] (asio::error_code ec, tcp::socket peer) {
      if (!ec) {
        auto session = std::make_shared<Session>(std::move(peer));
        session->start();
      }
      accept();
    };
    acceptor.async_accept(acceptHandler);
    }
  tcp::acceptor acceptor;
};
```

#subsubsection("Asynchronous Acceptor -> accept()")
- creates an accept handler that is called when an incoming connection has been established
  - the second parameter is the socket of the newly connected client
  - A session object is created (on the heap) to handle all communication with the client
  - accept() is called to continue accepting new inbound connection attempts
- the accept handler is registered to handle the next accept asynchronously
```cpp
auto accept() -> void {
  auto acceptHandler = [this] (asio::error_code ec, tcp::socket peer) {
    if (!ec) {
      auto session = std::make_shared<Session>(std::move(peer));
      session->start();
    }
    accept();
  };
  acceptor.async_accept(acceptHandler);
}
```

#subsubsection("Asychronous Acceptor (constructor)")
```cpp
Server(asio::io_context & context, unsigned short port)
      : acceptor{context, tcp::endpoint{tcp::v4(), port}}{
  accept();
}
```
- creates the sever
- initialized the acceptor with the given context and port
- calls accept for registering the accept handler for the next incoming conenction -> does not block

#subsubsection("Asychronous Acceptor (Use)")
```cpp
auto main() -> int {
  asio::io_context context{};
  Server server{context, 1234};
  context.run();
}
```
- creates an io\_context
 - has an associated executor that handles the async calls
- create the server on port 1234 (see above)
- Run the executor of the io\_context until no async operation is left
  - Since we already have an async\_accept request pending this operation does not return immediately
  - We will keep the this run() call busy
- *It is important that the server object llives as long as async operations on it are processed*

#subsection("Sessions with Async IO")
```cpp
struct Session : std::enable_shared_from_this<Session> {
  explicit Session(asio::ip::tcp::socket socket);
  auto start() -> void {
    read();
  }
private:
  auto read() -> void;
  auto write(std::string data) -> void;
  asio::streambuf buffer{};
  std::istream input{&buffer};
  asio::ip::tcp::socket socket;
};
```
- constructor stored the client connection
- start(): initiates the first async read
- read(): invokes async reading
- write(): invokes async writing -> called by handler in read
- the fields store the data of the session
- enable\_shared\_from\_this 
  This is needed in order to keep the session alive -> e.g. lives until function is done via incrementing reference counting\
  The session is defined as std::shared\_ptr:
  ```cpp
if (!ec) {
auto session = std::make_shared<Session>(std::move(peer));
session->start();
}
```\
The handler then increments the reference counter:
```cpp
//In the accept handler
void Session::read() {
auto handler = [self = shared_from_this()](error_code ec, size_t length) {
  // ..
}
```
#align(center, [#image("../Screenshots/2023_05_09_02_38_32.png", width: 70%)])

#subsection("Async Operations without Callbacks")
- specify special objects as callbacks
- asio::use\_future
  - returns std::future\<T\>
  - Errors are communicated via exception in future
- asio::detached
  - ignores the result of the operation -> fire and forget
- asio::use\_awaitable (cpp 20, probably not usable)
  - returns asio::awaitable\<T\> which can be awaited in coroutine

#subsection("Signal Handling")
```cpp
#include <asio.hpp>
#include <csignal>
#include <iostream>

auto main() -> int {
  auto context = asio::io_context{};
  auto signals = asio::signal_set{context, SIGINT, SIGTERM};
  signals.async_wait([&](auto error, auto sig) {
    if (!error) {
      std::cout << "received signal: " << sig << '\n’;
    } else {
      std::cout << "signal handling aborted\n";
    }
  });
  context.run();
}
code
```
- waits for an event and executes completion handler specified
- note, you can't wait for SIGKILL and SIGSTOP, these actions will always happen

#subsection("Accessing Shared Data")
```cpp
auto main() -> int {
  auto context = asio::io_context{};
  // start some async operations
  through asio::io_context
  auto runners = std::vector<std::thread>{};
  for(int i{}; i < 4; ++i) {
    runners.push_back(std::thread{[&]{
      context.run();
    }});
  }
  io_context.run()
  asio::io_context!
  for_each(runners.begin(), runners.end(),
           [](auto & runner){
            runner.join();
           });
}
```
- Multiple async operations can be in flight -> reading rom multiple sockets
- All completion handlers are dispatched through asio::io\_context
  - handlers run on a thread executing io\_context.run()
  - multiple threads can call run() on the same asio::io\_context
  - *could lead to data races!*
    ```cpp
// example for potential datarace
// globally accessible
auto results = std::vector<int> { };
// in connection class
asio::async_read(socket, asio::buffer(buffer), [&](auto err, auto bytes) {
auto result = parse(buffer);
results.push_back(result); // << data race here
});
    ```

#subsubsection("Strands")
#text(purple,[ensure sequential execution of signal handlers])
- implicit strands 
  - if only one thread calls io\_context.run()
  - our program blocks calling multiple handlers
- explicit strands
  - objects of type asio::strand\<\>
  - created using asio::make\_strand(executor)
  - asio::make\_strang(execution\_context)
  - applied to handlers using asio::bind\_executor(strand, handler)
    ```cpp
// same code as above, now with strands -> data race resolved
// globally accessible
auto results = std::vector<int> { };
auto strand = asio::make_strand(context);
// in connection class
asio::async_read(socket, asio::buffer(buffer),
asio::bind_executor(strand, [&](auto err, auto bytes) {
auto result = parse(buffer);
results.push_back(result); // <<< No more data race
}));
```

#section("Exception Safety Levels")

#subsection("Types of code with exceptions")
#subsubsubsection("Exception throws")
This code will throw exceptions

#subsubsubsection("Exception handling")
This code will handle exceptions

#subsubsubsection("Exception neutral")
This code will neither handle nor throw exceptions, it will simply forward all exceptions.

#subsection("Levels of Safety")
- noexcept -> no throw
  This code will never throw an exception
  Note, the code might still have throws internally -> but it will also handle them directly
  aka it will not throw towards the caller
- strong exception safety:
  Operation succeeds and no exception is thrown, or nothing happens and an exception is thrown
- basic exceptin safety:
  does not leak resources in case of exception, but might not be complete -> not all operations done
- no guarantee
  You have to make sure there are no data leaks, dangling pointers etc.
-  function is only as exception safe as it's weakest link.
   
#subsubsection("No Guarantee")
```cpp
auto & operator=(BoundedBuffer const & other) {
  if (m_container != other.m_container) {
    m_capacity = other.m_capacity;
    // what if this allocation throws?
    m_container = new char[sizeof(T) * m_capacity];
    m_position = 0;
    m_size = 0;
    for (auto const & element : other){
      this->push(element); // what if a copy throws?
    }
  }
  return *this;
}
code
```
- Don't use this
- Invalid or corrupted data when an exception is thrown
- easy to implement, kekw, aka no handling

#subsubsection("Basic Guarantee of an Operation")
```cpp
template<typename...TYPE>
static auto make_buffer(const int size, TYPE&&...param) -> BoundedBuffer<value_type> {
  int const number_of_arguments = sizeof...(TYPE);
  if (number_of_arguments > size)
    throw std::invalid_argument{"Invalid argument"};
    // the only safety
  BoundedBuffer<value_type> buffer{size};
  buffer.push_many(std::forward<TYPE>(param)...);
  return buffer;
}
```
- no resource leaks
- invariants are ok

However, the push\_many() function might also throw -> aka the operation might not be completed

```cpp
auto push_many() -> void { }
template<typename FIRST, typename...REST>
auto push_many(FIRST && first, REST&&...rest) -> void {
  push(std::forward<FIRST>(first));
  push_many(std::forward<decltype(rest)>(rest)...);
}
auto push(value_type const & elem) -> void {
  if(full()) throw std::logic_error{"full"};
    auto pointer = reinterpret_cast<value_type*>(dynamic_container_) + tail_;
  new (pointer) value_type{elem}; // might throw due to copy
  tail_ = (tail_ + 1) % (capacity() + 1);
  elements_++;
}
```
Note the throw, this means the element might not be pushed

#subsubsection("Strong Guarantee")
```cpp
auto & operator=(BoundedBuffer const & other) {
  if (this != &other) {
    BoundedBuffer copy {other}; // might throw
    swap(copy); // mustn't throw
  }
  return *this;
}
```
Problem: What happens when both functions throw?\
How to guarantee that at least one function does not throw?

- hard to guarantee a sequence
- might need undo functions if exception happens
- function that executes effect may not throw

#subsubsection("No-Throw")
```cpp
auto std::vector<T>::empty() const noexcept -> bool;
auto std::vector<T>::size() const noexcept -> size_type;
auto std::vector<T>::capacity() const noexcept -> size_type;
auto std::vector<T>::data() noexcept -> T *;
// all iterator factories begin(), end()...
auto std::vector<T>::clear() noexcept -> void;
```
- memory allocations can't do noexcept -> might always fail
  hence pushback and popback can't be noexcept

#subsubsection("Overview")
#align(center, [#image("../Screenshots/2023_05_16_01_45_02.png", width: 70%)])

#subsection("No Except")
- noexcept(false): default
- noexcept == noexcept(true) -> shorthand
- noexcept(function()): asks if the function is noexcept -> returns bool
- noexcept can't be overloaded

```cpp
auto function() noexcept -> void {
  //...
}

template<typename T>
auto function(T t) noexcept(<expression>) {
  // the noexcept here checks if the expression is noexcept -> does NOT actually run it!
  // then proceeds to set this functions noexcept based on the expression -> same except level!
}

auto main() -> int {
  std::cout << "is function() noexcept? " << noexcept(function()) << '\n';
  // returns bool whether or not function is noexcept
}
```

#subsubsection("Explosive example")
```cpp
template <unsigned ChanceToExplode>
struct Liquid;
using Nitroglycerin = Liquid<75>;
using JetFuel = Liquid<10>;
using Water = Liquid<0>;
template <typename Liquid>
struct Barrel {
  Barrel(Liquid && content): content{std::move(content)} {}
  auto poke() noexcept(noexcept(std::declval<Liquid>().shake())) {
    content.shake();
  }
private:
  Liquid content;
};
```
#subsubsection("Members should not throw")
- destructors...
- move constructors
- swap
- any sort of allocation or memory moving

#subsubsection("std::move_if_noexcept")
```cpp
template <typename T>
constexpr typename std::conditional<
!std::is_nothrow_move_constructible<T>::value && std::is_copy_constructible<T>::value,
const T&,
T&&
>::type move_if_noexcept(T & x);
```
#align(center, [#image("../Screenshots/2023_05_16_02_10_35.png", width: 70%)])
#text(purple, [this moves the value if the type has a no except move operation -> otherwise copy])\
Example:
```cpp
template<typename T>
class _box {
  T value;
  public:
  explicit _box(T const &t) noexcept(noexcept(T(t))) :
  value(t) {}
  explicit _box(T && t) noexcept(noexcept(T(std::move_if_noexcept(t)))) :
  value(std::move_if_noexcept(t)) {}
  auto get() noexcept -> T &{
    return value;
  }
};
```

#subsubsection("Contracts")
C++ has no native support for contracts, meaning it is only software engineering thing.\
- narrow contract
  - function expectes specific parameters -> may only be in range 50-100 etc
  - other preconditions
  - might not work properly if you don't make sure to pass the right stuff
- wide contract
  - function accepts any paramter with the correct type -> does internal checking
  - will never fail
  - no undefined behavior (if done properly)

Example:
```cpp
// wide contract
auto size() const _GLIBCXX_NOEXCEPT -> size_type {
  return size_type(this->_M_impl._M_finish - this->_M_impl._M_start);
}
// narrow contract:
explicit BoundedBuffer(size_type capacity): startIndex { 0 }, 
                                            nOfElements { 0 }, 
                                            capacity { capacity }, 
                                            values { allocate(capacity) } {
  if (capacity == 0) {
    throw std::invalid_argument { "size must be > 0." };
  }
}
```

#subsubsection("Compiler and Noexcept")
- compiler might optimize better with noexcept -> no stack unwinding preparation
- compiler will not warn you if you use exceptions with noexcept....
  - in this case std::terminate() will be called to avoid udef
    ```cpp
    struct Ball {};
    auto barrater() noexcept -> void {
      throw Ball{};
      // terminate called!!
    }
    auto main() try -> int {
        barrater();
      } catch(Ball const & b) {
        std::cout << "caught the ball!";
      }
    }
    ```

#section("Pimpl Idiom")
#subsection("Opaque types")
These are types that were declared first, but without definition.\
Then later the actual definition is used:
```cpp
struct S; //Forward Declaration
auto foo(S & s) -> void {
  foo(s);
  //S s{}; //Invalid
}
struct S{}; //Definition
auto main() -> int {
  S s{};
  foo(s);
}
```
The same is done in C with void \* -> casting to the actual type later (unsafe, kek)
```cpp
template<typename T>
auto makeOpaque(T * ptr) -> void * {
  return ptr;
}
template<typename T>
auto ptrCast(void * p) -> T * {
  return static_cast<T*>(p);
}
auto main() -> int {
  int i{42};
  void * const pi {makeOpaque(&i)};
  cout << *ptrCast<int>(pi) << endl;
}
```

#subsection("Pointer to Implementation")
#text(purple, [This is used in order to avoid recompilatin for each file that uses the library.\
C++ is a kappa language, which somehow recompiles the entire file if you use a library function directly.])
```cpp
class Wizard { // all magic details visible
std::string name;
MagicWand wand;
std::vector<Spell> books;
std::vector<Potion> potions;
auto searchForSpell(std::string const & wish) -> std::string;
Potion mixPotion(std::string const & recipe);
auto castSpell(Spell spell) -> void;
auto applyPotion(Potion phial) -> void;
public:
Wizard(std::string name = "Rincewind") :
name{name}, wand{} {}
auto doMagic(std::string const & wish) -> std::string;
  //...
};
```
In other words, if you change something here, then you will need to recompile all files that use wizard, as it has been seen as a change in that file.\
To fix this, make the wizard a pointer wrapper to the implementation, hence the name pimpl.
```cpp
//wizard.hpp
class Wizard {
  std::shared_ptr<class WizardImpl> pImpl;
public:
  Wizard(std::string name = "Rincewind");
  auto doMagic(std::string wish) -> std::string;
};

// wizard.cpp
//Implementation of Wizard
Wizard::Wizard(std::string name):
pImpl{std::make_shared<WizardImpl>(name)} {}
auto Wizard::doMagic(std::string wish) -> std::string {
  return pImpl->doMagic(wish);
}

// class moved here
#include "Wizard.hpp"
#include "WizardIngredients.hpp"
#include <vector>
#include <algorithm>
class WizardImpl {
  std::string name;
  MagicWand wand;
  std::vector<Spell> books;
  std::vector<Potion> potions;
  auto searchForSpell(std::string const & wish) -> std::string;
  auto mixPotion(std::string const & recipe) -> Potion;
  auto castSpell(Spell spell) -> void;
  auto applyPotion(Potion phial) -> void;
  public:
  WizardImpl(std::string name) : name{name}, wand{}{}
  auto doMagic(std::string const & wish) -> std::string;
  //...
};
```
#text(purple, [Since we moved the entire class into a cpp, we no longer include the file in all other files -> hence, we no longer need to recompile everywhere.])

#subsubsubsection("Defining size -> for unique pointer")
#text(purple, [The problem with unique pointer, is that it requires the type to be sized, which the type WizardImpl isn't at this point.\
So we need to define a destructor for the WizardImpl:])
```cpp
// wizard.hpp
class Wizard {
  std::unique_ptr<class WizardImpl> pImpl;
  // size needs to be known here for wizardimpl
public:
  Wizard(std::string name);
  ~Wizard();
  auto doMagic(std::string wish) -> std::string;
};

// wizard.cpp
//class WizardImpl {
  //...
};
//...
Wizard::~Wizard() = default;
// this line makes it work
// no implicit destructor for wizard -> at this point size for wizard impl is known
// now you can let c++ auto define the destructor for the wizard wrapper
```
#align(center, [#image("../Screenshots/2023_05_16_02_43_26.png", width: 70%)])
- pimpl should generally not be nullptr -> or rather not possible to be nullptr, should have used rust
- don't inherit from the pimpl class
  - not that I ever would since inheritance is crap.


#section("Hourglass Interfaces")
#subsection("ABI")
- name mangling
  - used for things like overloading
  - seen in c++ or rust
- calling conventions
- instruction sets -> intel64, arm, risc-V
- c++ does not define a specific ABI as it is coupled to the platform
  - done by the compiler -> GCC/G++ for example
- ABIs change between OS, compiler, versions, library versions etc.

#subsubsection("Comparison to C")
- C also does not define a specific ABI
  - but it is more stable
    - no mangling
    - no namespaces
    - hence also no:
      - exceptions
      - templates
      - member functions on structs or classes

#subsection("Idea")
The general idea of the hourglass interface is that you have an ABI that will allow you to use any language in order to use libraries.\
Aka you can use c++ libraries with rust if you so chose to, for whatever reason.
#align(center, [#image("../Screenshots/2023_05_23_01_29_24.png", width: 70%)])
#text(purple, [Here the C ABI, which is more stable than the c++ library is used, hence it should be expected to work.])

#subsubsection("Library")
```cpp
struct Wizard {
  Wizard(std::string name = "Rincewind") : name{name}, wand{} {}
  auto doMagic(std::string const & wish) -> char const *;
  auto learnSpell(std::string const & newspell) -> void;
  auto mixAndStorePotion(std::string const & potion) -> void;
  auto getName() const -> char const * {
    return name.c_str();
  }
};
```
#subsubsection("ABI")
- represented by abstract pointers
- member functions are handled by taking the abstract pointer as first argument -> see python and rust
- requires factory and disposal functions to manage object lifetime
- strings are represented by char\*
- exceptions do not work across C ABI
  - instead you can store the message of exceptions in parameters
  - errors need to be cleaned up when they are no longer used -> char\* !
```C
// define abstract wizard
typedef struct Wizard * wizard;
// const version
typedef struct Wizard const * cwizard;
// create function
wizard createWizard(char const * name, error_t * out_error);
void disposeWizard(wizard toDispose);
typedef struct Error * error_t;
char const * error_message(error_t error);
void error_dispose(error_t error);
char const *doMagic(wizard w, char const * wish, error_t *out_error);
void learnSpell(wizard w, char const * spell);
void mixAndStorePotion(wizard w,
char const * potion);
char const *wizardName(cwizard w);
```
#text(purple, [This can also be done in C++ with extern C:])
```cpp
#ifdef __cplusplus
extern "C" {
  #endif
  typedef struct Wizard * wizard;
  typedef struct Wizard const * cwizard;
  wizard createWizard(char const * name,
  error_t * out_error);
  void disposeWizard(wizard toDispose);
  // ...
  // Comments are ok too, as the preprocessor
  // eliminates them anyway
  #ifdef __cplusplus
}
#endif
```
- no overloading in extern
- only primitive types and pointers 
- structs are not the same as in c++
- always forward declare structs!
- enums unscoped
- #text(purple, [Note, not all things are unallowed, namespaces can be used, they will simply be put back into the global scope at compile time\
  Aka in here, the compiler will make the code C compliant, therefore making sure the ABI stability is guaranteed.])

#subsubsection("Binding ABI to the library (Trampolin)")
```cpp
// wizard.cpp
extern "C" {
  struct Wizard { // C linkage trampolin
  Wizard(char const * name) : wiz{name} {}
  unseen::Wizard wiz;
};

// wizard.hpp
namespace unseen {
  struct Wizard {
    Wizard(std::string name = "Rincewind") : name{name}, wand{} {}
    auto doMagic(std::string const & wish) -> char const *;
    auto learnSpell(std::string const & newspell) -> void;
    auto mixAndStorePotion(std::string const & potion) -> void;
    auto getName() const -> char const * {
      return name.c_str();
    }
  };
}
```
This binds the implementation in C++ to the C ABI by using namespaces.\
Aka c++ defines both without causing naming issues\
#text(red, [The wrapper is just needed in order to use the c++ features like overloads and templates.\
Hence we need a C compatible wrapper, which is just a constructor that will be bound to a struct in C.])\
Again note, it does not mean that you need to use straight C, just C ABI compatible code!

#subsubsection("Dealing with Exceptions")
- no references in C ABI -> pointer to pointer
- in case of error, allocate error value on heap -> string
  - provide disposal function as well
- no usage of c++ types
- it is safe to return char const \* -> receiving function owns the error string
  - hence also needs to dispose of allocated memory!

#subsubsubsection("Creating Error Messages")
```cpp
template<typename Fn>
bool translateExceptions(error_t * out_error, Fn && fn)
  try {
    fn();
    return true;
  } catch (const std::exception& e) {
    *out_error = new Error{e.what()};
    return false;
  } catch (...) {
    *out_error = new Error{"Unknown internal error"};
    return false;
}

wizard create_wizard(const char * name, error_t * out_error) {
  wizard result = nullptr;
  translateExceptions(out_error,[&] {
    result = new Wizard{name};
  });
  return result;
}
```
- translation from exceptions to bools etc. -> primitive types
- map the info to an error struct
- remember, no reference possible -> pointer to pointer (pointy point)

#subsubsection("Client")
#subsubsubsection("Error Handling on the Client Side")
```cpp
// could be any language
// wizardclient.hpp
struct ErrorRAII {
  ErrorRAII(error_t error) : opaque {error} {}
  ~ErrorRAII() {
    if (opaque) {
        error_dispose(opaque);
    }
  }
  error_t opaque;
};

struct ThrowOnError {
  ThrowOnError() = default;
  ~ThrowOnError() noexcept(false) {
    if (error.opaque) {
      throw std::runtime_error{error_message(error.opaque)};
    }
  }
  operator error_t*() {
    return &error.opaque;
  }
private:
  ErrorRAII error{nullptr};
};
```
- map error codes back to exceptions if you would like to use exceptions
  - once again, exception types can't be mapped through! -> only messages
  - you could however use standard types, as you can store primitive types for resolution
- temporary object with destructor that can throw error ? wat
  - automatic type conversion passes adress of error content
  - make sure not to leak memory -> deallocation must succeed!


#subsubsubsection("General Usage")
```cpp
struct Wizard {
  // note the passing of the ThrowOnError
  // this will handle the storing of the error that can also propagate to the backend!
  Wizard(std::string const & who = "Rincewind") : wiz {createWizard(who.c_str(), ThrowOnError{})} {
  ~Wizard() {
    dispose_wizard(wiz);
  }
  auto doMagic(std::string const &wish) -> std::string {
    return ::do_magic(wiz, wish.c_str(), ThrowOnError{});
  }
  auto learnSpell(std::string const &spell) -> void {
    ::learn_spell(wiz, spell.c_str());
  }
  auto mixAndStorePotion(std::string const & potion) -> void{
    ::mix_and_store_potion(wiz, potion.c_str());
  }
  auto getName() const -> char const * {
    return wizard_name(wiz);
  }
private:
  Wizard(Wizard const &) = delete;
  Wizard & operator=(Wizard const &) = delete;
  wizard wiz;
};
```

#subsubsubsection("DLL Hiding (Compiler Dependent)")
```cpp
#define WIZARD_EXPORT_DLL [[gnu::visibility("default")]]
WIZARD_EXPORT_DLL
char const * error_message(error_t error);
WIZARD_EXPORT_DLL
void error_dispose(error_t error);
WIZARD_EXPORT_DLL
wizard create_wizard(char const * name,
error_t *out_error);
WIZARD_EXPORT_DLL
void dispose_wizard(wizard toDispose);
WIZARD_EXPORT_DLL
char const * do_magic(wizard w,
char const * wish,
error_t *out_error);
WIZARD_EXPORT_DLL
void learn_spell(wizard w, char const *spell);
WIZARD_EXPORT_DLL
void mix_and_store_potion(wizard w, char const *potion);
WIZARD_EXPORT_DLL
char const * wizard_name(cwizard w);
```
- use -fvisibility=hidden with GCC and clang in order to make library symbols hidden
  - see above: all symbols that should be visible must be marked as such 
- can also be done with windoof: \_\_declspec(dllexport)

#subsection("Jafuck Natice Access (JNA)")
- generates interfaces at runtime
- single jar
- cross platform -> compile once debug everywhere

#subsubsubsection("Mappings")
#align(center, [#image("../Screenshots/2023_05_23_02_27_32.png", width: 70%)])

#subsubsubsection("Loading")
```java
public interface CplaLib extends Library {
  CplaLib INSTANCE = (CplaLib) Native.load("cpla", CplaLib.class);
}
```
- loader searches for suitable library -> libname.so libname.dylib libname.dll etc
  - first in path specified by jna.library.path
  - otherwise system default library path
  - fallback into classpath

#subsubsubsection("Interfacing with Functions")
```java
public interface CplaLib extends Library {
  CplaLib INSTANCE = (CplaLib) Native.load("cpla", CplaLib.class);
  // function that is defined in ABI
  void printInt(int number);
}
```
- names and types must match!
  - see mappings!
- parameter names do not matter

#subsubsubsection("Interfacing with non-opaque Structs")
```C
extern "C" {
  struct Point {
    int x;
    int y;
  };
  void printPoint(Point point);
}
```
Can be translated to jafuck as follows:
```java
// translation
public interface CplaLib extends Library {
  CplaLib INSTANCE = (CplaLib) Native.load("cpla", CplaLib.class);
  public static class Point extends Structure implements Structure.ByValue {
    public int x, y;
    Point(int x, int y) {
      this.x = x;
      this.y = y;
  }
    @Override
    protected List<String> getFieldOrder() {
      return List.of("x", "y");
    }
  }
  void printPoint(Point point);
}

// USAGE
CplaLib.Point p = new CplaLib.Point(12, 90);
CplaLib.INSTANCE.printPoint(p);
```
- structs from C must override the getFieldOrder() function
  - this function is needed since jafuck reorders members as it wants, but in C it is fixed, this makes sure the mapping still works!
- can use tag-interface Structure.ByValue
- you can access references with getPointer -> remember, jafuck has a garbage collector, might be cleaned up -> nullptr

#subsubsubsection("Interfacing with opaque Structs")
```C
extern "C" {
  typedef struct Unicorn * unicorn;
  unicorn createUnicorn(char * name);
  void disposeUnicorn(unicorn instance);
  void printUnicorn(unicorn unicorn);
}
```
This can be converted to jafuck as follows:
```java
public interface CplaLib extends Library {
  CplaLib INSTANCE = (CplaLib) Native.load("cpla", CplaLib.class);
  public static class Unicorn extends Pointer {
    Unicorn(String name) {
      super(Pointer.nativeValue(INSTANCE.createUnicorn(name)));
    }
    void dispose() {
      INSTANCE.disposeUnicorn(this);
    }
  }
  Pointer createUnicorn(String name);
  void disposeUnicorn(Unicorn instance);
  void printUnicorn(Unicorn unicorn);
}

// USAGE
CplaLib.Unicorn u = new CplaLib.Unicorn("freddy");
CplaLib.INSTANCE.printUnicorn(u);
u.dispose();
```
- for opaque structs, you should inherit from Pointer, wowie inheritance, fuck me
  - provide a constructor for this -> create()
- managing lifetimes is not trivial -> not automatic
  - provide a dispose method or implement AutoClosable and use it with try-with-resources (wat?)
  - using dispose() in finalizers is not recommended

#subsubsubsection("Using Raw byte arrays")
```C
extern "C" {
  char * getData(int * size);
  void freeData(char * data);
}
```
Conversion to jafuck:
```java
public interface CplaLib extends Library {
  CplaLib INSTANCE = (CplaLib) Native.load("cpla", CplaLib.class);
  Pointer getData(IntByReference size);
  void freeData(Pointer data);
}

// USAGE
IntByReference size = new IntByReference();
Pointer data = CplaLib.INSTANCE.getData(size);
byte[] javaData = data.getByteArray(0, size.getValue());
CplaLib.INSTANCE.freeData(data);
for(byte b : javaData) {
  System.out.println(b);
}
```
- use IntByReference to retrieve the size of the buffer
  - requires that API supports this
- getByteArray() copies data from the buffer
- make sure to free the buffer (why even bother with java then......)
  - either with using free()
  - or Native.free()
    - apparently crashes on windoof because fuck you
