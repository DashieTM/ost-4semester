\documentclass[main.tex,fontsize=8pt,paper=a4,paper=portrait,DIV=calc,]{scrartcl}
\input{../ost-summary-template.tex}

\begin{document}
\tableofcontents

\lstset{
    language=c++,
    style=code,
}

\newcommand{\TITLE}{CPP Advanced}
\newcommand{\AUTHOR}{Fabio Lenherr}
\setcounter{tocdepth}{1}

\section{Move Semantics}

\subsection{Copy}
\textcolor{purple}{By default cpp will always create copies, this is good for memory safety etc, as you will not be returning null values, but it can be a runtime hit!}\newline
\textcolor{teal}{(There are some special types that can't be copied like mutexes etc)}
\begin{lstlisting}
// Copy contructor
class something {
  something(const something &other) {
    // copy values from other
  }
}
\end{lstlisting}

\subsection{Move}
\textcolor{purple}{Move constructor will \emph{NOT copy values, instead, it will move these values into the new object, this is better for performance, but it requires more management from the programmer!}}\newline
\textcolor{teal}{Make sure to free the memory at the old object, otherwise you might be dealing with nullpointers!}
\begin{lstlisting}
Vector(Vector<T> &&vec)
    : size(vec.size), cap(vec.cap), data(std::move(vec.data)) {
  vec.data = nullptr;
} // yes this is the vector that you implemented kekw
\end{lstlisting}
\textcolor{red}{In short, the move constructor makes a lot of sense when you have \emph{Heap data}, aka if you have something like an array or a vector, then you will want to make sure to always use the move constructor if you can do so.}\newline
The default move constructor is as follows:
\begin{lstlisting}
struct S {
  S(S && s) : member{std::move(s.member)}
  {...}
  M member;
};
\end{lstlisting}

\subsection{Copy Assignment}
Default copy assignment constructor:
\begin{lstlisting}
struct S {
  auto operator=(S const& s) -> S& {
     member = s.member;
     return *this;
  }
  M member;
};
\end{lstlisting}

\subsection{Move Assignment}
Default move assignment constructor:
\begin{lstlisting}
struct S {
  auto operator=(S&& s) -> S& {
    member = std::move(s.member);
    return *this;
  }
  M member;
};
\end{lstlisting}

\subsection{Rvalue and Lvalue}
\textcolor{purple}{lvalue T\&: \emph{variable with some location in ram}, either on the stack or on the heap.}\newline
\textcolor{purple}{rvalue T\&\&: \emph{temporary value} that has no variable and no location in memory, it only exists in code.}\newline
\begin{lstlisting}
int a = 5;
// 5 is an r value, it has no memory location
// a is an lvalue -> some address is set to 5

int b = 10;

int c = a + b;
// a + b is an rvalue -> value is 15, but no memory location for this calculation
// c is an lvalue -> some address is set to 5
\end{lstlisting}

\subsubsection{Convert lvalue to rvalue}
\textcolor{purple}{By default you can't just use an lvalue as an rvalue, however, you can use \emph{std::move} to explicitly convert an lvalue to an rvalue.\newline
Note that in this case, you \emph{can't use the old variable anymore, as the data has been moved! -> see rust}}
\begin{lstlisting}
auto consume(Food&& food) -> void;

auto fryBurger() -> Food;
auto fastFood() -> void {
  Food fries{"salty and greasy"};
  consume(fryBurger()); //call with rvalue
  consume(fries); //cannot pass lvalue to rvalue reference
  consume(std::move(fries)); //explicit conversion lvalue to xvalue
  Food&& burger = fryBurger(); //life-extension of temporary
}
\end{lstlisting}

\subsection{Other value types}
\includegraphics[scale=0.4]{2023_02_28_01_43_39.png}
\includegraphics[scale=0.35]{2023_02_28_01_44_08.png}\newline
\begin{itemize}
\item \textcolor{purple}{lvalue}
  \begin{itemize}
  \item \textcolor{black}{address can be taken}
  \item \textcolor{black}{Can be on the left-hand side of an assignment if modifiable}
  \item \textcolor{black}{Can be used to initialize lvalue references}
  \item \textcolor{black}{Examples: variables, function calls that return reference, increment and decrement operators, array index access if array is lvalue}
  \item all string literals
  \end{itemize} 
\item \textcolor{purple}{prvalue}
  \begin{itemize}
  \item \textcolor{black}{address can't be taken -> doesn't exist}
  \item \textcolor{black}{cannot be on the left hand side of assignment}
  \item \textcolor{black}{temporary "materialization" to xvalue}
  \item \textcolor{black}{Examples: literals, false, nullptr, function call with non reference return type, postincrement and postdecrement!! }
  \end{itemize} 
\item \textcolor{purple}{xvalue}
  \begin{itemize}
  \item \textcolor{black}{address cannot be taken}
  \item \textcolor{black}{Cannot be used as left-hand operator of built-in assignment}
  \item \textcolor{black}{Conversion from prvalue through temporary materialization}
  \item \textcolor{black}{Examples: function calls with rvalue reference return type -> std::move, access of non-references members of an rvalue object, arra index access when array is rvalue}
  \end{itemize} 
\end{itemize}

\subsubsection{Temporary Materialization}
Getting from something imaginary to something you can point to....\newline
When this happens:\newline
\begin{itemize}
\item \textcolor{purple}{binding a reference to a prvalue}
\item \textcolor{purple}{when accessing a member of prvalue}
\item \textcolor{purple}{when accessing an element of a prvalue array}
\item \textcolor{purple}{when converting a prvalue array to a pointer}
\item \textcolor{purple}{when initializing an std::initializer\_list<T> from a braced-init-list}
\item \textcolor{red}{Type needs to be complete and needs to have a destructor}
\end{itemize} 
\begin{lstlisting}
struct Ghost {
  auto haunt() const -> void {
    std::cout << "booooo!\n";
  }
  //~Ghost() = delete;
};
auto evoke() -> Ghost {
  return Ghost{};
}
auto main() -> int {
  Ghost&& sam = evoke(); // bind reference to a prvalue
  Ghost{}.haunt(); // access member of prvalue
}
\end{lstlisting}

\subsection{l and rvalue references}
\begin{itemize}
\item \textcolor{purple}{lvalue reference} \textcolor{red}{made only of lvalues!!}
  \begin{itemize}
    \item type: T\&
  \item \textcolor{black}{alias for a variable}
  \item \textcolor{black}{can be used as function member type, local member/variable, return type}
  \item \textcolor{black}{be aware of dangling references when returning!}
  \end{itemize} 
\item \textcolor{purple}{rvalue reference} \textcolor{red}{made of rvalues, prvalues or xvalues!}
  \begin{itemize}
    \item \textcolor{black}{Type: T\&\&}
  \item \textcolor{black}{when assigned to a name (for example inside of a function), then it is actually an lvalue!!}
  \item \textcolor{black}{Argument is either a literal or a temporary object}\newline 
    \begin{lstlisting}
    std::string createGlass() -> std::string;
void fancyNameForFunction() { 
  std::string mug{"cup of coffee"};
  std::string&& glass_ref = createGlass(); //life-extension of temporary
  std::string&& mug_ref = std::move(mug); //explicit conversion lvalue to rvalue
  int&&
  i_ref = 5;
  //binding rvalue reference to prvalue
}
    \end{lstlisting}
  \end{itemize} 
\end{itemize} 

\subsection{Binds}
\includegraphics[scale=0.3]{2023_02_28_02_08_52.png}
\includegraphics[scale=0.35]{2023_02_28_02_09_12.png}\newline
\includegraphics[scale=0.35]{2023_02_28_02_10_51.png}
\includegraphics[scale=0.3]{2023_02_28_02_11_11.png}

\subsection{Destructor}
\textcolor{purple}{Whenever you need to write an explicit destructor, please make sure that you will not throw exeptions here. This can cause memory to not be freed, which.... well you guess what heppens}
\textcolor{teal}{In general you should make sure that \emph{ANY form of memory management doesn't throw exceptions!!!}}

\subsection{Default Constructors and user defined Constructors}
\includegraphics[scale=0.4]{2023_02_28_02_42_32.png}\newline
\textcolor{teal}{The ! means that it is a standard library bug, don't use those defaulted ones!!!}\newline
\textcolor{red}{Note that deleting a constructor will be the same as "user declared"!!}

\end{document}
